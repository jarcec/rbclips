%=========================================================================
\chapter{Úvod}
%=========================================================================
TODO: Dopsat zvnaneni proc jsme se rozhodli napsat tento wrapper, popsat jednotlive kapitoly

%=========================================================================
\chapter{Pou¾ité technologie}
%=========================================================================
Má bakaláøská práce se zabývá spojením dvou technologií, Ruby a CLIPS, které jsou v následujících sekcích detailnìji popsány.

\section{Ruby}
Ruby\cite{webRuby} je relativnì nový dynamický skriptovací jazyk vytvoøený japonským in¾enýrem Yukihiro Matsumoto známym pod pøezdívkou Matz. V souèasné dobì neexistuje ¾ádná specifikace èi norma jako je tomu napøíklad u jazykù C/C++ a dal¹ích. Z tohoto dùvodu se jako reference jazyka bere samotný interpret napsaný Matzem\,--\,Matz' ruby intepret (MRI). Interpretù existuje více a jejich zkrácený seznam je uveden dále v textu. Absence existujícího standartu vedla v roce 2008 k vytvoøení skupiny pro standardizaci tohoto jazyka v rámci japonské organizace Information-technology Promotion Agency (IPA), která vychází z MRI verze 1.8.7. V souèasné dobì je k dispozici ji¾ návrh standartdu\footnote{http://ruby-std.netlab.jp/draft\_spec/agreement.html}, který má být navr¾en ke schválení prvnì v japonsku u Japanese Industrial Standards Committee (JISC) a následnì i u International Standard Organization (ISO).

\subsection{Historie}
První verze interpretu ruby vytvoøená Matzem byla zveøejnìna u¾ v roce 1995 (velice zajimavý je fakt, ¾e jméno nového jazyka u¾ bylo vybráno v roce 1993, tedy o cele dva roky døíve), ov¹em oficální webové stránky jazyka (interpretu) v angliètinì byly k dispozici a¾ o tøi roky pozdìji\,--\,tedy v roce 1998. Absence kvalitních materiálù v angliètinì je jedním z hlavních dùvodù, proè se ruby stal populárním prvnì pouze v japonsku a velice pomalu se dostával i do ostatních státu svìta. V dne¹ní dobì u¾ na¹tìstí není problém najít kvalitní zdroje informací ani v angliètinì ani v èe¹tinì, èi dál¹ích jazycích, a to jak ve webové tak i v kni¾ní podobì. Tyto i dal¹í zajimavá data jsou shrnuta na Obrázku \ref{ruby_history}, která jsem èerpal z prezentace vytvoøené k pøíle¾itosti konference RubyConf 2006\footnote{http://blog.nicksieger.com/articles/2006/10/20/rubyconf-history-of-ruby}.

Matz vytvoøil nový jazyk, proto¾e ho nadchly mo¾nosti skriptovacích jazyku a ¾adný z tehdy dostupných jazykù ho nezaujal\footnote{http://linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html} - chtìl jazyk mocnìj¹í ne¾ Perl\footnote{http://www.perl.org/} a více objektì orientovaný ne¾ Python\footnote{http://www.python.org/}.  Na otázku, proè vytvoøil dal¹í skriptovací jazyk, Matz je¹tì èasto dodává dùvody syntaxe - programovacích jazykù je mnoho a jsou svým zpùsobem velice podobné (vlastnostmi i schopnostmi). Matz ov¹em chtìl jazyk, ve kterém ho bude bavit psát a nebude se muset pøíli¹ trápit se zápisem jednotlivých konstrukcí. Syntaxe by mìla být podøízena èlovìku jako¾to pisateli jazyka, nikoliv opaènì poèítaèi jako¾to interpretu jazyka.

\begin{figure}[tbh]
  \begin{tabular}{|c|l|}
    \hline
    1993 & Vybráno jméno \\
    1995 & První zveøejnìná verze interpretu (verze 0.95) \\
    1996 & Verze 1.0 \\
    1997 & Matz zamìstnán jako full-time ruby programátor \\
    1998 & Webové stránky v angliètinì a vznik anglicky psaného mailing listu \\
    1999 & První kniha o ruby (psána japonsky) \\
    2000 & Zaèátek roz¹iøování povìdomí o ruby mimo hranice Japonska \\
    2001 & YARPC - Yet Another Ruby and Perl Conference \\
    \hline
  \end{tabular} 

  \caption{Shrnutá historie v datech}
  \label{ruby_history}
\end{figure}

V souèasné verze se udr¾ují dvì hlavní vìtve MRI\,--\,verze 1.8 a 1.9. Vìtev 1.8 je pova¾ována za stabilní a ji¾ se pouze udr¾uje (opravují se chyby), hlavní vývoj probíhá ve vìtvi~1.9.

\subsection{Vlastnosti ruby}
Ruby je dynamický skriptovací jazyk mnoha ruzných paradigmat\,--\,je plnì objektovì orientovaný, ale lze v nìm bez problémù psát i imperativnì èi funkcionálnì. Následuje popis vybraných vlastností, které bych rád vyzdvihl èi na nì upozornil. Podle poøeby budu dále v textu srovnávat Ruby s dal¹ímy jazyky které znám - Java\footnote{http://www.java.com/en/} a C++\footnote{http://www.cplusplus.com/}.

Ní¾e uvedený popis vlastností jsem èerpal ze své osobní zku¹enosti s tímto programovacím jazykem, z velice obsáhleho popisu jazyka napsaného samotným autorem ruby The Ruby programming language\cite{rubyProgrammingLanguage}, co¾ je zrevidování a roz¹íøení døíve vydané knihy, která je v ruby svìtì známa pod názvem Ruby in Nutshel\cite{rubyInNutshel}, a z knihy Metaprogramming Ruby\cite{metaprogrammingRuby}, která se zabývá nejen metaprogramováním v ruby, ale take velice èitelným zpùsobem vysvìtluje objektový model ruby a dal¹í jeho aspekty.

TODO: Seznam vlastnosti

\subsubsection{Objektovost}
Ruby je plnì objektovì orientovaný jazyk (byl mimo jiné inspirován i Smalltalkem\footnote{http://www.smalltalk.org/main/}), co¾ znamená, ¾e v¹e v ruby je objekt. Nejsou zde ¾ádná datová primitiva jako v Javì (int, double) a C++. \u{C}íselné a jiné konstanty jsou interpretem okam¾itì pøevádìny na instance pøíslu¹ných tøíd. Pøíklad na Obrázku \ref{ruby_objektovost_fig1} ukazuje mo¾nost volání metody na èíselnou konstantu bez nutnosti explicitní objektivizace.

\begin{figure}[tbh]
	\begin{verbatim}
	123.class # => Fixnum
	\end{verbatim}
  \vspace{-0.7cm}
  \caption{Automatická objektivizace èíselných konstant}
  \label{ruby_objektovost_fig1}
\end{figure}

Interpret po svém startu vytvoøí bezejmenou instanci tøídy Object a v jejím¾ kontextu naslednì vykoná pøedaný skript. Není zde tedy nutnost vytváøet tøídu s minimálnì jednou veøejnou metodu, která se spustí po startu aplikace jako je tomu v Javì popøípadnì funkci main() v pøípadì C++. Ukázkový ``Hello world!'' program, který v ruby vypadá takto: \verb|puts "Hello world!"|, je tedy objektový k\'{o}d, i kdy¾ se tak na první pohled nezdá. Tvrzení lze dokazát vypsaním tøídy aktualního objektu \verb|puts self.class|, která vratí ``Object'' i kdy¾ pro pisatele v ¾ádném objektu není (\verb|self| je obdoba ukazatele \verb|this| z jazyka C++, tedy ``ukazatel'' na aktuální objekt),

Dal¹í a pro mì v dobì, kdy jsem s ruby poprvé seznamoval, velice pøekvapivý dùsledek plné objektovosti je fakt, ¾e tøídy samy jsou objekty. Napøíklad objekt ``abcd'' je tøídy \verb|String|, a samotná tøída/objekt \verb|String| je zase tøídy \verb|Class|, co¾ jde vidìt na Obrázku \ref{ruby_objektovost_fig2}. Z tohoto pøístupu plynì nìkolik dùsledkù: (1) je potøeba rozli¹ovat mezi tøídní metodou a instaèní metodou, (2) tøídy mohou mít své instaèní promìné, (3) existuje mo¾nost dìdit i na mno¾inì objektù, ze kterých se vytváøejí tøídy. Z praktického pohledu se na tuto vlastnost lze koukat jako na statické promìné a metody u jazyka C++.

\begin{figure}[tbh]
	\begin{verbatim}
	"abc".class # => String
	String.class # => Class
	\end{verbatim}
  \vspace{-0.7cm}
  \caption{Ruby tøída je normální objekt}
  \label{ruby_objektovost_fig2}
\end{figure}

Schopnosti dìdit na mno¾inì objektù, ze kterých se vytváøejí tøídy vyu¾ívá i objektový model Ruby. Tøída \verb|Class| pou¾ívaná pro tvorbu tøíd napøíklad dìdí od tøídy \verb|Modul|, kterou roz¹iøuje hlavnì o metodu \verb|new| slou¾ící pro tvorbu nových instancí. Modul je zjednodu¹ená tøída, kolekce metod, od které nelze vytváøet instance ov¹em lze je vkládat dovnitø jiných tøíd a tím nahrazovat absenci vícenásobné dìdiènosti v Ruby.

%\begin{figure}[ht]
%  \centering
%  \includegraphics[width=8cm,keepaspectratio]{fig/fig-ruby-inst_obj.png}
%  \caption{Promìné, metody a jejich umístìní v instancích a tøídách}
%  \label{fig_ruby_inst_obj}
%\end{figure}
%
%Tøídy jsou v ruby také objekty (instance jiné tøídy - konkrétnì tøídy Class) - mají tedy své instanèní promìné a lze na nich volat metody (které %jsou umístìny v tøídì dané tøídy).
%
%\begin{figure}[ht]
%  \centering
%  \includegraphics[width=12cm,keepaspectratio]{fig/fig-ruby-inst_obj_2.png}
%  \caption{Tøída je také objekt}
%  \label{fig_ruby_inst_obj_2}
%\end{figure}

\subsubsection{Volná syntaxe}
Jak u¾ bylo zmínìno vý¹e, Matz chtìl vytvoøit jazyk, ve kterém by ho bavilo programovat. Jazyk ve kterém by nemusel poøád pøemý¹let nad syntaxí, který by byl krásnì èitelný a hlavnì pokud mo¾no co nejbli¾¹í bì¾nému lidskému jazyku. Cíl se mu povedl, proto¾e ukázky k\'{o}du (viz Obrázek \ref{ruby_syntaxe_fig1}) opravdu pøi ètení pøipomínájí anglické vìty, popisující co se má dìlat.

\begin{figure}[tbh]
	\begin{verbatim}
	3.times do puts 'Ahoj'
	puts "Ahoj" if name == "jarcec"
	\end{verbatim} 
	\vspace{-0.7cm}
  \caption{Ukázky èitelnosti k\'{o}du}
  \label{ruby_syntaxe_fig1}
\end{figure}

Jedním ze zpùsobu pøízpùsobìní gramatiky jazyka programátorovi je mo¾nost nepsat závorky oddìlující název metody od jejich parametrù v místech, kde to není syntakticky nejednoznaèné. Mohu tedy zavolat metodu \verb|naDruhou| s parametrem 5 tak jak je zvykem v Javì/C++ \verb|naDruhou(5)|, nebo na mnoha místech více èitelnìji \verb|naDruhou 5|. Volání metod bez závorek vypadá na mnoha místech jako klíèové slovo, které spí¹e nìco deklaruje ne¾ obyèejné volání metody. Na první pohled se to mù¾e jevit spí¹e jako matoucí, ale uvedený  pøíklad (Obrázek \ref{ruby_syntaxe_fig2}) z webového frameworku Ruby on Rails\footnote{http://rubyonrails.org/} (dále v textu pou¾ívám zkratku RoR) ukazuje opak.

\begin{figure}[tbh]
	\begin{verbatim}
	class Human < ActiveRecord::Base
		has_many     :articles
		belongs_to   :department
	end
	\end{verbatim} 
	\vspace{-0.7cm}
  \caption{ActiveRecord ukázka prezentující volitelné pøeskoèení závorek}
  \label{ruby_syntaxe_fig2}
\end{figure}

I èlovìk bez znalosti Ruby nebo RoR, ale se znalostí jiných programovacích jazykù, je schopen s velkou úspì¹ností odhadnout, ¾e prezentovaný pøíklad vytváøí tøídu Human, s urèitou závislostí na oddìlení (department), a který napsal mnoho rùzných èlánkù (articles).

Tento spí¹e sociální efekt (``Jedná se o metodu nebo klíèové slovo?'') jde velice hluboko. Mnohdy lze u¾ úvodních tutoriálech k Ruby najít zmínku o klíèovém slovu \verb|puts|, slou¾ícím pro výpis na standartní výstup (obdoba \verb|printf()| z C, \verb|echo| z Bashe nebo \verb|print| z Perlu). Ve skuteènosti se ov¹em nejedná o klíèové slovo, ale o metodu modulu \verb|Kernel|, který ka¾dy objekt dìdí a proto je na ka¾dém místì programu dostupná - jedná se tedy plnohodnotnou metodu a jde stejnì jako jakákoliv jíná v pøípade potøeby pøetí¾it popøípadnì z objektu odstranit...

Odstranìní nutnosti psát v¹ude závorky beru jako kladnou vlastnost, kterou velice èasto a rád vyu¾ívám. Na druhou stranu ov¹em musím upozornit na její dopady - i pouhá mezera mù¾e zmìnit logiku kódu s jakou bude zpracován. Na Obrázku \ref{ruby_syntaxe_fig3} uvadím dva pøíklady li¹ící se pouhou jednou mezerou mezi koncem názvu metody a otevírající závorkou. V prvním pøípadì syntaktický analyzátor najde ihned za názvem metody závorku. Ví tedy, ¾e uvnitø se nacházejí parametry, se kterými se metoda má volat a a¾ následná vrácená hodnota se vynasobí dvìma. Výsledek bude $18$ (=$3^2  * 2$). V druhém pøíkladì syntaktický analyzátor najde za názvem metody mezeru a pøístupuje k volání jinak. Ví, ¾e následuje seznam argumentù oddìlený èárkami, proto¾e závorky okolo argumentù jsou vynechány. Na øádce se ov¹em ¾ádná èárka nenachazí a tedy celý výraz $(1+2)*2$ je metodì pøedán jako jeden argument s výsledkem $36$ (=$((1+2) * 2)^2$).

\begin{figure}[tbh]
	\begin{verbatim*}
	puts naDruhou(1+2)*2
	puts naDruhou (1+2)*2
	\end{verbatim*}
 	\vspace{-0.7cm}
  \caption{Dùle¾itý význam mezer}
  \label{ruby_syntaxe_fig3}
\end{figure}

Ruby neumo¾nuje pojmenovat argumenty metod podobnì jako python, ov¹em díky volné syntaxi pro vytvoøení asociativního pole (hashe) lze toto chování napodobit. Pøíkladem mù¾e být volání fiktivní metody pro hledání \verb|find :name => 'Jarek', :surname => 'Cecho'|, kde opticky pøedávám dva pojmenované parametry - name a surname. Ve skuteènosti je tento zápis reprezentován jako tvorba asociativního pole s klièi name a surname (s pøíslu¹nými hodnotami) a¾ naslednì toto pole je jako jeden argument pøedáno metodì \verb|find|. Webový framework Ruby on Rails tento pøístup pou¾ívá velmi èasto.

Poslední poznámka o volné syntaxi, Ruby umo¾nuje stejnì jako perl otoèení poøadí zápisu neúplné podmínky a jejího tìla (viz. Obrázek \ref{ruby_syntaxe_fig3}).

\begin{figure}[tbh]
	\begin{verbatim}
	if osoba == 'jarcec' then print "Ahoj Jarcec"; end
	print "Ahoj Jarcec" if osoba == 'jarcec'
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøehození poøadí zápisu neúplnì podmínky a jejího tìla}
  \label{ruby_syntaxe_fig4}
\end{figure}

\subsubsection{Dynamiènost a otevøenost}
Dynamièností Ruby rozumím provádìní mnoha èinností, které jsou provádìny v pøípadì C++ èi Javy v dobì kompilace, a¾ za bìhu programu. Vzhledem k plné objektovosti nemá moc smysl mluvit o typovosti jazyka, proto¾e existuje pouze jediný datový typ, kterým je objekt.

Z dynamiènosti vyplývá mnohem zajimavìj¹í a ne a¾ tak bì¾ná vlastnost Ruby, kterou je otevøenost. Ka¾dý objekt mù¾e být za bìhu otevøen a roz¹íøen o nové metody podobnì jako je tomu u JavaScriptu. Velice \u{c}asto se toho vyu¾ívá u tøíd (napøíklad roz¹íøením vìstavìné tøídy o nové metody). Tuto vlastnost by do urèité míry ¹lo nahradit dìdièností (nové metody ulo¾it do potomka), ale jen pokud se roz¹iøují tøídy. V Ruby je v¹e objekt, tak¾e roz¹íøit jdou nejen tøídy, ale i instance jednotlivých tøíd (viz Obrázek \ref{ruby_dynamicnost_fig1}), co¾ byl pro mì jako¾to programátora v C++ docela ¹ok pøi seznamování se s tímto jazykem. Mo¾nosti roz¹íøení instancí o nové metody pou¾ívám i ve své práci, co¾ popisuji ní¾e v kapitole o zpracování Faktù.

\begin{figure}[tbh]
	\begin{verbatim}
	class A
		def metodaA
			4
		end
	end

	a = A.new
	a.metodaA # => 4

	b = A.new
	def b.metodaB
		5
	end
	b.metodaB # => 5
	a.metodaB # => Exception NoMethodError
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøehození poøadí zápisu neúplnì podmínky a jejího tìla}
  \label{ruby_dynamicnost_fig1}
\end{figure}

Díky dynamiènosti a otevøenosti se v ruby velice pìknì metaprogramuje (co¾ je mnohoznaèný výráz, zde pou¾ívám ve významu psaní k\'{o}du, který generuje dal¹í k\'{o}d). Jedná se o velice èasto vyu¾ívanou schopnost jazyka a velké projekty v Ruby jsou metaprogramováním dosti ovlivnìny. Pøíkladem mù¾e být projekt ActiveRecords\footnote{http://ar.rubyonrails.org/}, který zapouzdøuje èinnost s relaèními databázemi tak, aby se u¾ivatel se SQL vùbec nesetkal (v¹e je zapouzdøeno do objektù).

\begin{figure}[tbh]
	\begin{verbatim}
	class Human < ActiveRecords::Base
	end

	jarcec = Human.new
	jarcec.name = "Jarek"
	jarcec.surname = "Cecho"
	jarcec.save
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ukázka pou¾ití knihovny ActiveRecords}
  \label{ruby_dynamicnost_fig2}
\end{figure}

V definici tøídy z Obrázku \ref{ruby_dynamicnost_fig2} chybí deklarace method \verb|name| a \verb|surname| a pøesto daný k\'{o}d bude fungovat. Konstruktor tøídy se toti¾ pøi inicializaci podívá do databáze na strukturu tabulky kterou popisuje, v tomto pøípadì tabulky \verb|humans| a vytvoøí ke v¹em nalezeným sloupcùm pøíslu¹né metody pro ètení i zápis. Tento pøístup usnad\u{n}uje údr¾bu k\'{o}du. V definice tøídy není seznam sloupcù jednotlivých tabulek a proto pøi zmìnì databázového schématu není nutné v¹e upravovat a zvedat tak pravdìpodobnost zavleèení chyby (nekonzistence seznamu sloupcù v databázi a v definici tøídy).

O metaprogramování v ruby byla napsána velice pìkná kniha - Metaprogrammin Ruby\cite{metaprogrammingRuby}. Psána je spí¹e laickým stylem a na praktických pøíkladech popisuje co pøesnì se pod pojmem metapogramovaní skrývá, a jak toho v ruby co nejefektivnìji vyu¾ít.

\subsubsection{Bloky}
Blok je podobnì jako v C++ nebo Javì mno¾ina pøíkazù ohranièená slo¾enymí závorkami. V pøípadì ruby je je¹tì mo¾né blok ohranièit klíèovými slovy \verb|do| a \verb|end|. Na rozdíl od zmínìných jazykù v Ruby jde s bloky dìlat o dost vìt¹í kouzla a proto je zmi\v{n}uji v samostatné èásti. První dùle¾itý rozdíl je mo¾nost pøedat bloku parametry (a ten se pak vlastnì chová jako bezejmená funkce). Dal¹í rozdíl je schopnost bloky v Ruby pøedávát do method.

\begin{figure}[tbh]
	\begin{verbatim}
	["AHOJ", "NAZDAR", "HI"].map{|prvek| prvek.downcase}
			# => ["ahoj", "nazdar", "hi"]
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ukázka pøedání bloku metodì}
  \label{ruby_bloky_fig1}
\end{figure}

Pøíkladem mù¾e být zámìna velikosti písmen v poli øetezcù na Obrázku \ref{ruby_bloky_fig1}. \verb|map| je metoda tøídy \verb|Array|, která pøijímá blok akceptující jeden parametr a pro ka¾dý prvek v poli tento blok zavolá. Návratovou hodnotu bloku (v ruby je v¹e výraz, i bloky tedy vracejí své hodnoty, tato vlastnost je detailnìji popsána ní¾e) ulo¾í do pole na místo volaného prvku. Ukázka tedy zmen¹í velikost písmen pro kazdý prvek v poli.

S bloky se pojí jeden dùle¾íty pojem - uzávìr (anglicky closure). Ka¾dý blok si s sebou nese vazby na lokální promìné známe v dobì jeho vzniku (takzvané bindings). V pøíkladì na Obrázku \ref{ruby_bloky_fig2} si blok ``zapamatuje`` svou lokální promìnou \verb|a| (s hodnotou 30) a nese si ji s sebou i do metody \verb|foo|, odkud je poté zavolán (pomocí klíèového slova \verb|yield|). Ukázka výpí¹e èíslo 30, proto¾e \verb|a| je lokální promìná z kontextu, ve kterém byl pøedaný blok vytvoøen. Pokud by chtìla metoda \verb|foo| vytisknout svou hodnotu promìné \verb|a|, musela by ji pøedat do bloku jako parametr.

\begin{figure}[tbh]
	\begin{verbatim}
	def foo
		a = 10
		yield # Zavolej predany blok
	end

	a = 30
	foo { puts a } # Vytiskne hodnotu promene a, ale ktere? 10 nebo 30?
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Vazby na lokální promìné v pøípadì pøedaných blokù}
  \label{ruby_bloky_fig2}
\end{figure}


\subsubsection{Drobnosti}
Dále bych se chtìl u¾ jenom krátce zmínit o nìkolika vlastnostech Ruby, které popisem nevydají na samostatnou kapitolu, ale pøesto si myslím, ¾e by zde mìly být uvedeny.

Mimo toho, ¾e v¹e je v ruby objekt, je ka¾dá jazyková konstrukce výraz (má svou hodnotu). Tedy i øídicí konstrukce (\verb|if|, \verb|while|, ...) nìco vrací - podle funkce pøíslu¹né konstrukce je to tøeba poslední vykonaný pøíkaz nebo \verb|nil| (Obrázek \ref{ruby_drobnosti_fig1}).

\begin{figure}[tbh]
	\begin{verbatim}
	if 1 == 2
	  puts "1 == 2"
	end # => nil
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig1}
\end{figure}

Ruby je plnì objektový a v¹e je objekt popøípadnì jeho metoda. I aritmetické operátory jsou tedy ve skuteènosti metody a jejich zápis bez pøístupové teèky je jen ''syntax sugar`` (jak se uvádí v knize  The Ruby Programming Language\cite{rubyProgrammingLanguage}). Jde je tedy podobnì jako v C++ pøetí¾it nebo z daného objektu úplnì odstranit (Obrázek \ref{ruby_drobnosti_fig2}).

\begin{figure}[tbh]
	\begin{verbatim}
	class Fixnum
	  def +(oth)
	    self * oth
	  end
	end #	=> nil
	4 + 2 #	=> 8
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig2}
\end{figure}

Ruby podporuje pouze jednoduchou dìdiènost, tøída mù¾e mít maximálnì jednoho pøedka. Ov¹em absenci implementaènì slo¾ité vícenásobné dìdiènosti vynahrazuje mo¾ností vkládat do sebe moduly (Obrázek \ref{ruby_drobnosti_fig3}).

\begin{figure}[tbh]
	\begin{verbatim}
	module Ahoj
	  def ahoj
	    "Ahoj"
	  end
	end
	class Pozdravy
	  include Ahoj
	end
	p = Pozdravy.new
	p.ahoj # => "Ahoj"
\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig3}
\end{figure}

Na rozdíl od C++ èi Javy jsou v Ruby povoleny na konci metod jiné znaky ne¾ jen znaky anglické abecedy. Co¾ má veliký dopad na zlep¹enou èitelnost k\'{o}du, jeliko¾ podle konvencí metody vracející booleanovskou hodnotu (true/false) jsou ukonèeny znakem otázníku (napøíklad \verb|Object#nil?|) a metody mìnící stav samotného objektu jsou pro zmìnu ukonèeny vykøièníkem (napøíklad \verb|Array#map!|).

\subsection{Ostatní implementace ruby}
Nejznámìj¹í a asi i nejvíce pou¾ívanou implementací jazyka Ruby je interpret MRI (Mat'z ruby interpreter) od autora jazyka. Ten má ov¹em své nedostatky (není nejrychlìj¹í, neumo¾nujì opravdový paralerismus proto¾e obsahuje ''Global interpreter lock`` - v jednu chvíli mù¾e bì¾et maximálnì jedno vlákno). Jako podklad pro tento list jsem pou¾il seznam rùzných interpretù a jejich krásné srovnání na webu igvita\cite{webIgvitaInterprets}.

\subsubsection{Ruby Enterprise edition}
Jde o fork MRI implementace verze 1.8.7\cite{webRubyEE} s vylep¹enou správou pamìti a vymìnìným garbage collectorem (MRI vyu¾ívá mark-and-sweep GC). Vznikl jako potøeba optimalizovat ruby pro bìh na serverech pro webové aplikace postavené na Ruby on Rails a je pro nì optimalizován. Je plnì kompatibilní s ruby verze 1.8.7 a podle oficiálních stránek v urèitých pøípadech a¾ o 33\% rychlej¹í. Na portále RubyInside\cite{webRubyEERecord} je k dispozici záznám pøedná¹ky obou autorù toho forku z konference Google Tech Talk (2009, San Francisco), o dùvodech proè se do forku pustili a také o optimalizacích, které provedli.

\subsubsection{JRuby}
Je implementace ruby v Jave\cite{webJRuby} a vyu¾ívající mo¾ností Java VM - obsahuje plnou paralerizaci (¾ádný GIL), v souèastosti se pracuje na podpoøe ruby verze 1.9. Velmi ¾ivý projekt se 7 aktivními vývojáøi (MRI z nejvìt¹í èásti vyvíjí jeden èlovìk).

\subsubsection{BlueRuby}
Jedná se o implementaci ruby bì¾ícího uvnitø SAP NetWeaver a SAP ERP produktù, tedy dal¹í mo¾nost jak roz¹íøit SAP mimo jazykù ABAP a Java. Zatím je projekt pouze ve stádiu experimentální implementace\cite{webBlueRuby} a nehodí se pro reálné nasazení - je naimplementováno pouze okolo 75\% vlastní ruby podle ruby specs.

\subsubsection{Rubinius}
Zajimavý nápad napsat co nejvìt¹í èást ruby v samotném ruby\cite{webRubinius} - jedná se o pøepsaní nezbytnì nutných èástí interpretu do C++ a zbývajícího k\'{o}du do ruby (jako napøíklad standartní tøídy - String, Array, Hash, ...). Intepret obsahuje JIT kompilátor - parsovaný skript kompiluje na místì do binárního k\'{o}du spustitelném na dané platformì a a¾ ten následnì spou¹tí, èím¾ dosahuje zrychlení oproti MRI. Díky kompilaci do nativního k\'{o}du není zatí¾en GIL a tedy umo¾nuje paralerismus. V souèasné dobì je tento projekt stále ve vývoji - nìkolik gemù a aplikací v nìm ji¾ bì¾í, ale pro reálné nasazení není pøíli¹ vhodný.

\subsection{Mo¾nosti binárního roz¹íøení}
MRI verze ruby, kterou jsme se rozhodli pou¾ít, proto¾e se jedná o referenèní implementaci ruby, je napsán v jazyce C a souèástí distribuèního tarballu je i README soubor obsahující rychlý úvod do psaní binárních roz¹íøení. Jako dal¹í zdroj informací odkud jsem èerpal uvedu vyèerpávající popis ruby The Ruby programming language\cite{rubyProgrammingLanguage}.

\subsubsection{VALUE}
\verb|VALUE| je datový typ, který v C reprezentuje ruby objekt. V ruby je v¹e objekt, tak¾e se tento datový typ pou¾ívá v¹ude - ka¾dá funkce, která je volatelná z ruby, vrací \verb|VALUE| jako svou návratovou hodnotu. Ve skuteènosti je se jedná o pøejmenování datového typu \verb|unsigned long| obsahujícího adresu struktury, která daný objekt reprezentuje - ve vìt¹inì pøípadù se tedy jedná o ukazatel. Ov¹em ne ve v¹ech pøípadech - interpret vyu¾ívá faktu, ¾e ukazatele jsou na platformì x86 v pamìti zarovnány - nejni¾¹í dva bity jsou pro ukazatele v¾dy nulové (platí pro 32 bitovou architekturu, pro 64 bitù se zarovnává na 8 bytù - tedy poslední ètyøi bity ukazatele jsou nulové). Napøíklad objekty tøídy \verb|Fixnum| (reprezentující celá èísla), nemají svou strukturu pro popis objektu jako ostatní objekty, ale jejich hodnota je zak\'{o}dována pøímo do promìné typu \verb|VALUE|, tak ¾e nultý bit (LSB, Least significant bit, nejménì významný bit) je nastaven na jednièku a ostatní bit jsou pou¾ity pro ulo¾ení vlastní hodnoty èísla. Tímto pøístup se u¹etøí dereferencování ukazatele pøi práci s celými èísly. Samozøejmì zobrazitelný rozsah èísel je tímto pøístupem omezený na 31 bitù (èíslo je ulo¾eno v pamìti jako znaménkové v dopl\v{n}kovém k\'{o}du) a proto ruby pro ''velká`` èísla (ov¹em stále celá) nabízí ruby je¹tì tøídu \verb|Bignum|, její¾ hodnota není reprezentována pøímo v míste ukazatele a proto má o dost vìt¹í rozsah. 

Tato optimalizace není pou¾ita jen u celých èísel, ale také u singleton promìných významých a èasto pou¾ívaných tøíd. Singleton (èesky jsem na¹el pøeklad ''jedináèek`` nebo ''unikát``) je oznaèení situace kdy existuje právì jedna (popøípadnì maximálnì jedna) instance tøídy v celém programu. V ruby se jedná o instance tøíd \verb|TrueClass| (instance se jmenuje \verb|true|), \verb|FalseClass| (instancí je objekt \verb|false|) nebo \verb|NilClass| (instance je \verb|nil|, obdoba \verb|NULL| v jazyce C, ''prazdný`` nebo také ''¾ádný`` objekt). V¹echny tyto objekty tedy nemají reprezentující strukturu, ale jejich obsah je pøím zak'{o}dován do typu \verb|VALUE| pro rychlej¹í interpretaci skriptu.

\begin{figure}[ht]
  \centering
  \includegraphics[width=13.5cm,keepaspectratio]{./fig/ruby_value_diagram.png}
  \caption{Diagram pro reprezentaci hodnoty v promìné VALUE (pøevzatý obrázek \cite{webRubyValue})}
  \label{fig_ruby_value_diagram}
\end{figure}

\subsubsection{Pøeklad roz¹íøení}
Binární roz¹íøení se v ruby pøekládají pomocí pøíkazu \verb|make|, tak jak je tomu u vìt¹iny ostatních projektù v prostøedí linuxu, ov¹em na rozdíl od nich není pou¾ita sada programù autotools (skript ./configure pro generaci souboru Makefile). Makefile popisující jak se má roz¹íøení pøelo¾it a nainstalovat toti¾ vygeneruje samo ruby - existuje modul \verb|mkmf| (MaKe MakeFile), pomocí jeho¾ metod programátor popí¹e na vysoké úrovní abstrakce, jak pøelo¾it jeho roz¹íøení a tento skript potom distribuuje spolu se zdrojovými k\'{o}dy. Celý sled pøíkazù pro pøeklad a instalaci poté vypadá takto:

\begin{verbatim}
ruby extconf.rb
make
make install
\end{verbatim} 

Modul \verb|mkmf| slou¾í hlavnì k nastavení dùle¾itých cest pro pøeklad automaticky a nezávisle na dané verzi èi distribuci operaèního systemu (cesta k hlavièkovým souborùm ruby, jeho knihovnám). Mimo této èinnosti modul nabízí metody, které umo¾nují podobné èinnosti jako skript ./configure - nalezat cesty k systémovým knihovnám, ovìøováním zda-li obsahují po¾adované symboly (funkce, promìné, ...) a dal¹í podobné funkce. Takto vytvoøený skript je samozøejmì plnìhodnotný program v ruby, lze tedy pou¾ít ve¹keré jeho mo¾nosti vèetnì pou¾ití dal¹ích ruby knihoven (lze napøíklad distribuovat pouze skript bez zdrojových k\'{o}dù, který si prvnì stáhnì nejnovìj¹í verzi projektu a a¾ poté bude pokraèovat ve své obvyklé èinnosti).

\subsubsection{Symboly}
\verb|Symbol| je jeden z  datových typù ruby, jeho¾ popis patøí spí¹e do sekce o vlastnostech, ale kvùli velké návaznosti na jeho vnitøní implementaci jsem se rozhodl zaøadit zmínku o nìm a¾ v této kapitole. \verb|Symbol| je textový øetìzec podobný øetìzcùm tøídy \verb|String|, který se pro odli¹ení pí¹e s dvojteèkou pøed vlastním øetezcem. Pokud je symbol navíc slo¾en pouze z písmen, je mo¾né vynechat i jindy povinné uvozovky èi apostrofy:

\begin{verbatim}
irb(main):001:0> :ahoj.class # => Symbol
irb(main):002:0> :'ahoj'.class # => Symbol
irb(main):003:0> :'ahoj, tady jezisek'.class # => Symbol
irb(main):004:0> :'4'.class # => Symbol
\end{verbatim} 

Symboly v ruby mají nìkolik odli¹ných vlastností od tøídy \verb|String| - za prvé se jedná o objekty pouze pro ètení (nejde zmìnit hodnota, text symbolu) a druhý a podstatnìj¹í rozdíl je v rovnosti a identitì. Uvedu vysvìtlující pøíklad:

\begin{verbatim}
irb(main):001:0> 'ahoj' == 'ahoj' # => true
irb(main):002:0> 'ahoj'.object_id == 'ahoj'.object_id # => false

irb(main):003:0> :ahoj == :ahoj # => true
irb(main):004:0> :ahoj.object_id == :ahoj.object_id # => true
\end{verbatim} 

Provádím dvì dvojice porovnání, porovnávám mezi sebou vlastnosti objektù tøíd \verb|String| a \verb|Symbol|. V prvním testu porovnávám objekty zda-li se rovnají (mají-li ted stejný obsah). Druhý test se ptá na ID (jednoznaèný identifikátor objektu) objektu a testuje tedy identitu objektu. Testy na rovnost samozøejmì v¾dy uspìjí, proto¾e jak symbol tak øetìzec obsahují stejné hodnoty. Ov¹em test na identitu v pøípadì øetìzce sel¾e, proto¾e se jedná o dva rùzné objekty (vytvoøené interpretem pøi parsování zdrojového k\'{o}du programu). Symboly jsou si ov¹em identické - jedná se o jednu instanci. Tato dùle¾itá vlastnost symboly pøedurèuje k pou¾ítí na místech konstant èí klíèù do asociativních polí - symbol s daným textem existuje v pamìti maximalnì jednou, bez ohledu na poèet výskytù v programu, co¾ vede k ¹etøení pamìtí a zvý¹ení výkonu aplikace.

Na úrovní zdrojových k\'{o}du MRI se jedná o tabulku, která jednoznaènì pøevádí textovou reprezentaci symbolu na datový typ \verb|ID| (co¾ je pøedefinovaný typ \verb|unsigned long|). Ve¹kerá porovnávání na rovnost symbolu jsou tedy ve skuteènosti celoèíselná porovnání, která jsou rychlej¹í ne¾ øetìzcová, èím¾ se dosahuje dal¹í optimalizace. Symbol je podobnì jako Fixnum pøímo zak\'{o}dován do typu \verb|VALUE|, nedochazí zde tedy k dereferencování ukazatele pro získaní této èíselné hodnoty a ta je získána pouze jednou pøi tvorbì objektu.

Pro práci se symboly nabízí MRI binarním roz¹íøení nìkolik funkcí:
\begin{itemize}
 \item \texttt{ID rb\_intern(const char *)} Pøevod libovolného øetìzce na \verb|ID|
 \item \texttt{ID rb\_to\_id(VALUE)} Pøevede hodnotu v ruby objektu tøídy \verb|String| nebo \verb|Symbol| na \verb|ID|
 \item \texttt{VALUE ID2SYM(ID)} Zpìtný pøevod \verb|ID| na objekt tøídy \verb|String|
\end{itemize}

\subsubsection{Shrnutí API}
Zde jen sepí¹u seznam dle mého názoru nejdùle¾itìj¹ích funkcí, které jsou interpretem nabízeny k pou¾ití v binárních roz¹íøeních. Mým cílem není podat jejich vyèerpávající seznam, ale pouze krátké shrnutí ukazující jakým zpùsobem se roz¹íøení v ruby pí¹í a jaké mají mo¾nosti, dal¹í dostupnì funkce lze najít v dokumentaci a zdrojích zmínìných na zaèatku kapitoly.

\paragraph{Vytváøení nových tøíd a metod}
\begin{itemize}
 \item \texttt{VALUE rb\_define\_class(const char *name, VALUE super)} Vytvoøí novou tøídu se jménem \verb|name| a tøídou \verb|super| jako rodièem.
 \item \texttt{VALUE rb\_define\_module(const char *name)} Vytvoøí nový modul s jménem \verb|name|.
 \item \texttt{rb\_define\_method(VALUE klass, const char *name, VALUE (*f)(), int argc)} Definuje metodu v tøídì \verb|klass| jména \verb|name|. Pøi jejím zavolání z ruby se zavolá funkce \verb|f()|, metoda jejího volání závisí na argument \verb|argc|, který je vysvìtlen ní¾e.
 \item \texttt{rb\_define\_module\_function(VALUE m, const char *name, VALUE (*f)(), int argc)} Vytvoøí metodu v modulu s podobnou sémantikou jako pøedchozí funkce.
 \item \texttt{rb\_define\_singleton\_method(VALUE o, const char *name, VALUE (*f)(), int argc)} Vytvoøí tøídní metodu (pøíkladem mù¾e být tøeba èasto pou¾ívaná metoda \verb|new| volaná na tøídì jako takové).
 \item \texttt{VALUE rb\_iv\_get(VALUE obj, const char *name)} Vra\v{t}í hodnotu instaèní promìné jména \verb|name| z objektu \verb|obj|.
 \item \texttt{VALUE rb\_iv\_set(VALUE obj, const char *name, VALUE val)} Nastaví hodnotu instaèní promìné \verb|name| objektu \verb|obj| na hodnotu \verb|val|.
\end{itemize}

Argument \verb|argc| u tìchto funkcí znamená poèet a tvar argumentù pøedaných funkci \verb|f()| pøi volání. Kladná hodnota znaèí poèet pøedavaných argumentù (maximálnì ov¹em 17, v¹echny budou typu \verb|VALUE|. V pøípadì záporné hodnoty bude funkce voláná jedním ze dvou zpùsobù - v pøípádì -1 jí bude pøedáno pole argumentù v jazyce C (\texttt{f(int argc, VALUE *argv, VALUE self)}) nebo v pøípadì -2 ji budou argument pøedaný v jednom ruby poli (\texttt{f(VALUE argv, VALUE self)}).

\paragraph{Obecnì u¾iteèné funkce}
\begin{itemize}
 \item \texttt{VALUE rb\_funcall(VALUE recv, ID mid, int narg, ...)} Zavolá metodu \verb|mid| objektu \verb|recv|, lze také chápat jako poslání zprávy \verb|mid| objektu \verb|recv|.
 \item \texttt{VALUE rb\_eval\_string(const char *str)} Pustí pøedaný øe\v{t}ezec jako ruby k\'{o}d v aktualním kontextu (lze z nìho tedy pøístupovat k lokálním èi instaèním promìným).
\end{itemize}

\paragraph{Makra a funkce pro práci s typy}
\begin{itemize}
 \item \texttt{TYPE(value)} Vrací typ objektu (pro vestavìné tøídy \verb|T_STRING|, \verb|T_ARRAY|,... pro jiné tøídy \verb|T_OBJECT|).
 \item \texttt{FIXNUM\_P(value)} Rychlej¹í varianta pouze kontrolující zda-li se jedná o èíslo tøídy \verb|Fixnum|.
 \item \texttt{NIL\_P(value)} Dal¹í rychlej¹í varianta, pouze zji¹tuje zda-li se jedná o \verb|nil| objekt.
 \item \texttt{FIX2LONG(value)} Konverze celého èísla (tøídy \verb|Fixnum|) na C typ \verb|long|.
 \item \texttt{rb\_float\_new(f)} Vytvoøení objektu reprezentujicího èíslo v plovoucí øadové èárce.
 \item \texttt{StringValueCStr(value)} Získání øe\v{t}ezce z ruby objektu tøídy \verb|String| (tedy získání \verb|const char *| ukazatele na øe\v{t}ezec).
\end{itemize}

OPTIONAL TODO: Popis toho co to je EigenClass
OPTIONAL TODO: Rozdily mezi moduly a tridy
OPTIONAL TODO: Zapouzrení a moznosti jeho obejiti - private je jen doporuceni na implicitni save, objekt\#instance\_eval

\section{Expertní systémy}
TODO: Popsat co jsou vlastne expertni systemy, jak se s nimi pracuje, cim se lisi od ostatnich, trochu historie.

\subsection{Clips}
TODO: Popsat historii CLIPS, co to je v dnesni dobe. Prakticke ukazky jak se v clips pracuje. Zahrnout kapitolu o rozsiritelnosti.

%=========================================================================
\chapter{rbClips}
%=========================================================================
TODO: Par vet o tom co jsme se rozhodli vytvorit a proc (proc wrapper nad necim co uz existuje).
TODO: Vlastni text...

%=========================================================================
\chapter{Závìr}
%=========================================================================
TODO: Taky by se hodil ze jo... ;-)
