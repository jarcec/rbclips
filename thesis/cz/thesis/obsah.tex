%=========================================================================
\chapter{Úvod}
%=========================================================================
Poèet novì se objevujících virù a jiných ¹kodlivých poèítaèových k\'{o}dù (malwaru) rok od roku stoupá. Velice tomu pomáhá postupné roz¹iøování internetu i mezí ménì informovanou laickou veøejnost, která se pøíli¹ netrápí dostateèným zapezpeèím svých poèítaèù. Tento nepøíli¹ optimistický trend zpùsobuje prolémy snad ve v¹ech odvìtvích, proto¾e dnes u¾ bez IT oddìlení nemù¾e existovat ¾ádná vet¹í firma. Zpùsobené problémy jsou hlavnì finanèí\,--\,rostou náklady jak na zabezpeèení jednotlivých poèítaèových stanic, tak i celých poèítaèívých sítí.

Logickou úvahou by mohl ètenáø dojít k názoru, ¾e na tomto trendu mimo spamerù profitují hlavnì rùzné bezpeèností firmy. Nejvíce pak antivirové spoleènosti, dodavající ochraná øe¹ení proti malwaru. \v{S}kodlivého k\'{o}du je ov¹em nejenom více, ale bohu¾el se takté¾ dost mìní. Jeho autoøi, kterých je stále více, vynalézají nové a dùmyslnìj¹í techniky jak pøedejít odhlanení antivirovým programem. Co¾ na stranì antivirových firem zmanená poptávku po stále vìt¹ím poètu velice dobøe kvalifikovaných lidí pro procházení podezøelých vzorkù a vytváøení nových virových definic.

Dostateèný poèet dobøe kvalifikovaných lidí bohu¾el na trhu práce není k dispozici a proto se hledají jiné, automatizovanìj¹í postupy, pro zpracování podezøelých vzorkù. Automatizované postupy mají navíc i jiné výhody. Poèítaè pracuje rychleji, mnohdy spolehlivìji a hlavnì výraznì levnìji ne¾ jeho lidský ekvivalent. Na druhou stranu mu chybí takzvaný ``zdravý selský rozum''. Pøirozené lidské my¹lení se jen velmi obtí¾nì implementuje do obvyklých procedurálních programù.

Pro adresaci problému lidského uva¾ovaní vznikly tkz. expertní systémy. Expertní systém je program, který napodobuje rozhodovací proces lidského experta podle pøedem nadefinovaných pravidel. V rámci spoleènosti AVG Technologies s.r.o jsme se rozhodli vytvoøit program za pou¾ití expertního systému pro automatickou klasifikaci vzorkù. Vìt¹ina expertních systému je komerèních a vzhledem k tomu, ¾e se nejedná o levné programy rozhodli jsme pou¾ít volnì ¹íøitelný pøíklad takového systému jménem CLIPS.

CLIPS je public domain software, je tedy zadarmo i pro komerèní vyu¾ití. Nabízí plnohodnotné prostøedí pro tvorbu expertního systému, které je napsáno v jazyce C. U¾ivatelské rozhrání, které je velice podobné jazyku LISP, je ov¹em u¾ivatelsky velice nepøívìtívé. Proto jsme se rozhodli celé CLIPS vzít a zapouzdøit do nìjakého vy¹¹ího programovacího jazyka. Jako cílový jazyk pro zapouzdøení jsme se rozhodli vyu¾ít moderní skriptovací jazyk Ruby, kvùli jeho zajimavým a neobvyklým mo¾nostem.

Má bakaláøská práce, která je v následujícíh kapitolách popsána, pojednává o novì vytvoøené knihovnì rbClips, která umo¾nuje pou¾ívat CLIPS v jazyce Ruby. Knihovna bude následnì pou¾ita k tvorbì systému pro automatické rozpoznávání vzorkù, tak jak bylo nastínìní na pøedcházejícíh øádcích. Samotný systém pro klasifikaci vzorkù u¾ ov¹em není rozsahém této práce.

V druhé kapitole bych rád popsal obì nastínìné technologie, které spojím do funkèního celku více do detailu. Budu se tedy pøednì vìnovat systému pro tvorbu expertních systému CLIPS a dynamickému skriptovacímu jazyku Ruby.

Tøetí kapitola je ji¾ popisem mé knihovny. Obsahuje jak její návrh, popis rozhraní tak i rùzné zajímavé implementaèní dropnosti.

%=========================================================================
\chapter{Pou¾ité technologie}
%=========================================================================
Jak jsem popsal v úvodu, cílem mé bakaláøské práce je vytvoøit knihovnu rbClips umo¾nující propojit CLIPS a Ruby. V následujících dvou kapitolách se obìma technologiím budu zabývat více do hloubky a vysvìtlím proè jsme se rozhodli pou¾ít právì je. Obì technologie jsou napsány v programovacím jazyce C, proto i moje knihovna bude napsána tém¾e jazyce. Samotný popis jazyka C jsem ji¾ ov¹em do své práce nezahrnul a lze najít napøíklad v knize \cite{programovaciJazykC}.

\section{Ruby}
Ruby\cite{webRuby} je relativnì mladý dynamický skriptovací jazyk vytvoøený japonským in¾enýrem Yukihiro Matsumoto známym pod pøezdívkou Matz. V souèasné dobì neexistuje ¾ádná specifikace èi norma jako je tomu napøíklad u jazykù C/C++ a dal¹ích. Z tohoto dùvodu se jako reference jazyka bere samotný interpret napsaný Matzem\,--\,Matz' ruby intepret (MRI). Interpretù existuje více a jejich zkrácený seznam je uveden dále v textu. Absence existujícího standartu vedla v roce 2008 k vytvoøení skupiny pro standardizaci jazyka v rámci japonské organizace Information-technology Promotion Agency (IPA), která vychází z MRI verze 1.8.7. V souèasné dobì je k dispozici ji¾ návrh standartdu\footnote{http://ruby-std.netlab.jp/draft\_spec/agreement.html}, který má být navr¾en ke schválení prvnì v japonsku u Japanese Industrial Standards Committee (JISC) a následnì i u International Standard Organization (ISO).

\subsection{Historie}
První verze interpretu Ruby vytvoøená Matzem byla zveøejnìna u¾ v roce 1995 (velice zajimavý je fakt, ¾e jméno nového jazyka u¾ bylo vybráno v roce 1993, tedy o cele dva roky døíve), ov¹em oficální webové stránky jazyka v angliètinì byly k dispozici a¾ o tøi roky pozdìji\,--\,tedy v roce 1998. Absence kvalitních materiálù v angliètinì je jedním z hlavních dùvodù, proè se Ruby stal populárním prvnì pouze v Japonsku a velice pomalu se dostával i do ostatních státu svìta. V dne¹ní dobì u¾ na¹tìstí není problém najít kvalitní zdroje informací ani v angliètinì ani v èe¹tinì, èi dál¹ích jazycích, a to jak ve webové tak i v kni¾ní podobì. Tyto i dal¹í zajimavá data jsou shrnuta na Obrázku \ref{ruby_history}, která jsem èerpal z prezentace vytvoøené k pøíle¾itosti konference RubyConf 2006\footnote{http://blog.nicksieger.com/articles/2006/10/20/rubyconf-history-of-ruby}.

Matz vytvoøil nový jazyk, proto¾e ho nadchly mo¾nosti skriptovacích jazyku a ¾adný z tehdy dostupných jazykù ho nezaujal\footnote{http://linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html} - chtìl jazyk mocnìj¹í ne¾ Perl\footnote{http://www.perl.org/} a více objektì orientovaný ne¾ Python\footnote{http://www.python.org/}.  Na otázku, proè vytvoøil dal¹í skriptovací jazyk, Matz je¹tì èasto dodává dùvody syntaxe - programovacích jazykù je mnoho a jsou svým zpùsobem velice podobné (vlastnostmi i schopnostmi). Matz ov¹em chtìl jazyk, ve kterém ho bude bavit psát a nebude se muset pøíli¹ trápit se zápisem jednotlivých konstrukcí. Syntaxe by mìla být podøízena èlovìku jako¾to pisateli jazyka, nikoliv opaènì poèítaèi jako¾to interpretu jazyka.

\begin{figure}[tbh]
  \begin{tabular}{|c|l|}
    \hline
    1993 & Vybráno jméno \\
    1995 & První zveøejnìná verze interpretu (verze 0.95) \\
    1996 & Verze 1.0 \\
    1997 & Matz zamìstnán jako full-time ruby programátor \\
    1998 & Webové stránky v angliètinì a vznik anglicky psaného mailing listu \\
    1999 & První kniha o ruby (psána japonsky) \\
    2000 & Zaèátek roz¹iøování povìdomí o ruby mimo hranice Japonska \\
    2001 & YARPC - Yet Another Ruby and Perl Conference \\
    \hline
  \end{tabular} 

  \caption{Shrnutá historie v datech}
  \label{ruby_history}
\end{figure}

V souèasné verze se udr¾ují dvì hlavní vìtve MRI\,--\,verze 1.8 a 1.9. Vìtev 1.8 je pova¾ována za stabilní a ji¾ se pouze udr¾uje (opravují se chyby), hlavní vývoj probíhá ve vìtvi~1.9.

\subsection{Vlastnosti ruby}
Ruby je dynamický skriptovací jazyk mnoha ruzných paradigmat\,--\,je plnì objektovì orientovaný, ale lze v nìm bez problémù psát i imperativnì èi funkcionálnì. Následuje popis vybraných vlastností, které bych rád vyzdvihl èi na nì upozornil. Podle poøeby budu dále v textu srovnávat Ruby s dal¹ímy jazyky které znám - Java\footnote{http://www.java.com/en/} a C++\footnote{http://www.cplusplus.com/}.

Ní¾e uvedený popis vlastností jsem èerpal ze své osobní zku¹enosti s tímto programovacím jazykem. Z velice obsáhleho popisu jazyka napsaného samotným autorem Ruby The Ruby programming language\cite{rubyProgrammingLanguage}. Co¾ je zrevidoví a roz¹íøení døíve vydané knihy Ruby in Nutshel\cite{rubyInNutshel}. A z knihy Metaprogramming Ruby\cite{metaprogrammingRuby}, která se zabývá nejen metaprogramováním v Ruby, ale také velice èitelným zpùsobem vysvìtluje objektový model ruby a dal¹í jeho aspekty.

Dále bych se rád blí¾e zabýval popisem objektovosti Ruby, jeho volnìj¹í syntaxí, dynamiènosti, otevøeností a popisu jak fungují bloky.

\subsubsection{Objektovost}
Ruby je plnì objektovì orientovaný jazyk (byl mimo jiné inspirován i Smalltalkem\footnote{http://www.smalltalk.org/main/}), co¾ znamená, ¾e v¹e v Ruby je objekt. Nejsou zde ¾ádná datová primitiva jako v Javì (int, double) a C++. \u{C}íselné a jiné konstanty jsou interpretem okam¾itì pøevádìny na instance pøíslu¹ných tøíd. Pøíklad na Obrázku \ref{ruby_objektovost_fig1} ukazuje mo¾nost volání metody na èíselnou konstantu bez nutnosti explicitní objektivizace.

\begin{figure}[tbh]
	\begin{verbatim}
	123.class # => Fixnum
	\end{verbatim}
  \vspace{-0.7cm}
  \caption{Automatická objektivizace èíselných konstant}
  \label{ruby_objektovost_fig1}
\end{figure}

Interpret po svém startu vytvoøí bezejmenou instanci tøídy Object a v jejím kontextu naslednì vykoná pøedaný skript. Odpadá tedy nutnost explicitnì vytváøet tøídu s minimálnì jednou veøejnou metodu, která se spustí po startu aplikace jako je tomu v Javì nebo funkci main() v pøípadì C++. Ukázkový ``Hello world!'' program, který v Ruby vypadá takto: \verb|puts "Hello world!"|, je tedy objektový k\'{o}d, i kdy¾ se tak na první pohled nezdá. Tvrzení lze dokazát vypsaním tøídy aktualního objektu \verb|puts self.class|, která vratí ``Object'' i kdy¾ pro pisatele v ¾ádném objektu není (\verb|self| je obdoba ukazatele \verb|this| z jazyka C++, tedy ``ukazatel'' na aktuální objekt),

Dal¹í a pro mì v dobì, kdy jsem se s Ruby poprvé seznamoval, velice pøekvapivý dùsledek plné objektovosti je fakt, ¾e tøídy samy jsou objekty. Napøíklad objekt ``abcd'' je tøídy \verb|String|, a samotná tøída/objekt \verb|String| je zase tøídy \verb|Class|, co¾ jde vidìt na Obrázku \ref{ruby_objektovost_fig2}. Z tohoto pøístupu plynì nìkolik dùsledkù: (1) je potøeba rozli¹ovat mezi tøídní metodou a instaèní metodou, (2) tøídy mohou mít své instaèní promìné, (3) existuje mo¾nost dìdit i na mno¾inì objektù, ze kterých se vytváøejí tøídy. Z praktického pohledu se na tuto vlastnost lze koukat jako na statické promìné a metody u jazyka C++.

\begin{figure}[tbh]
	\begin{verbatim}
	"abc".class # => String
	String.class # => Class
	\end{verbatim}
  \vspace{-0.7cm}
  \caption{Ruby tøída je plnohodnotný objekt}
  \label{ruby_objektovost_fig2}
\end{figure}

Schopnosti dìdit na mno¾inì objektù, ze kterých se vytváøejí tøídy vyu¾ívá i objektový model Ruby. Tøída \verb|Class| pou¾ívaná pro tvorbu tøíd dìdí od tøídy \verb|Modul|, kterou roz¹iøuje hlavnì o metodu \verb|new| slou¾ící pro tvorbu nových instancí. Modul je zjednodu¹ená tøída, kolekce metod, od které nelze vytváøet instance ov¹em lze je vkládat dovnitø jiných tøíd a tím nahrazovat absenci vícenásobné dìdiènosti v Ruby.

%\begin{figure}[ht]
%  \centering
%  \includegraphics[width=8cm,keepaspectratio]{fig/fig-ruby-inst_obj.png}
%  \caption{Promìné, metody a jejich umístìní v instancích a tøídách}
%  \label{fig_ruby_inst_obj}
%\end{figure}
%
%Tøídy jsou v ruby také objekty (instance jiné tøídy - konkrétnì tøídy Class) - mají tedy své instanèní promìné a lze na nich volat metody (které %jsou umístìny v tøídì dané tøídy).
%
%\begin{figure}[ht]
%  \centering
%  \includegraphics[width=12cm,keepaspectratio]{fig/fig-ruby-inst_obj_2.png}
%  \caption{Tøída je také objekt}
%  \label{fig_ruby_inst_obj_2}
%\end{figure}

\subsubsection{Volná syntaxe}
Jak u¾ bylo zmínìno vý¹e, Matz chtìl vytvoøit jazyk, ve kterém by ho bavilo programovat. Jazyk ve kterém by nemusel poøád pøemý¹let nad syntaxí, který by byl krásnì èitelný a hlavnì pokud mo¾no co nejbli¾¹í bì¾nému lidskému jazyku. Cíl se mu povedl, proto¾e ukázky k\'{o}du (viz Obrázek \ref{ruby_syntaxe_fig1}) opravdu pøi ètení pøipomínájí anglické vìty, popisující co se má udìlat.

\begin{figure}[tbh]
	\begin{verbatim}
	3.times do puts 'Ahoj'
	puts "Ahoj" if name == "jarcec"
	\end{verbatim} 
	\vspace{-0.7cm}
  \caption{Ukázky èitelnosti k\'{o}du}
  \label{ruby_syntaxe_fig1}
\end{figure}

Jedním ze zpùsobu pøízpùsobìní gramatiky jazyka programátorovi je mo¾nost nepsat závorky oddìlující název metody od jejich parametrù v místech, kde to není syntakticky nejednoznaèné. Mohu tedy zavolat metodu \verb|naDruhou| s parametrem 5 tak jak je zvykem v Javì/C++ \verb|naDruhou(5)|, nebo na mnoha místech více èitelnìji \verb|naDruhou 5|. Volání metod bez závorek vypadá na mnoha místech spí¹e jako klíèové slovo s cílem nìco deklarovat ne¾ obyèejné volání metody.

\begin{figure}[tbh]
	\begin{verbatim}
	class Human < ActiveRecord::Base
		has_many     :articles
		belongs_to   :department
	end
	\end{verbatim} 
	\vspace{-0.7cm}
  \caption{ActiveRecord ukázka prezentující volitelné vynechání závorek}
  \label{ruby_syntaxe_fig2}
\end{figure}

Na první pohled se to mù¾e jevit spí¹e jako matoucí, ale uvedený  pøíklad (Obrázek \ref{ruby_syntaxe_fig2}) z webového frameworku Ruby on Rails\footnote{http://rubyonrails.org/} (dále v textu pou¾ívám zkratku RoR) ukazuje opak. I èlovìk bez znalosti Ruby nebo RoR, ov¹em se znalostí jiného programovacího jazyka, je schopen s velkou úspì¹ností odhadnout, ¾e prezentovaný pøíklad vytváøí tøídu Human, s urèitou závislostí na oddìlení (department), a který napsal mnoho rùzných èlánkù (articles).

Tento spí¹e sociální efekt (``Jedná se o metodu nebo klíèové slovo?'') jde v Ruby velice hluboko. Mnohdy lze u¾ úvodních tutoriálech najít zmínku o klíèovém slovì \verb|puts| slou¾ícímu pro výpis na standartní výstup (obdoba \verb|printf()| z C, \verb|echo| z Bashe nebo \verb|print| z Perlu). Ve skuteènosti se ov¹em nejedná o klíèové slovo, ale o metodu modulu \verb|Kernel|, který ka¾dy objekt zdìdí a proto je na ka¾dém místì programu dostupná. Jedná se tedy zcela normální metodu a jde stejnì jako jakákoliv jíná v pøípade potøeby pøetí¾it popøípadnì z objektu odstranit...

Odstranìní nutnosti psát v¹ude závorky beru jako kladnou vlastnost, kterou velice èasto a rád vyu¾ívám. Na druhou stranu ov¹em musím upozornit na její dopady - i pouhá mezera mù¾e zmìnit logiku kódu s jakou bude zpracován. Na Obrázku \ref{ruby_syntaxe_fig3} uvadím dva pøíklady li¹ící se pouhou jednou mezerou mezi koncem názvu metody a otevírající závorkou. V prvním pøípadì syntaktický analyzátor najde ihned za názvem metody závorku. Ví tedy, ¾e uvnitø se nacházejí parametry, se kterými se metoda má volat a a¾ následná vrácená hodnota se vynasobí dvìma. Výsledek bude $18$ (=$3^2  * 2$). V druhém pøíkladì syntaktický analyzátor najde za názvem metody mezeru a pøístupuje k volání jinak. Ví, ¾e následuje seznam argumentù oddìlený èárkami, proto¾e závorky okolo argumentù jsou vynechány. Na øádce se ov¹em ¾ádná èárka nenachazí a tedy celý výraz $(1+2)*2$ je metodì pøedán jako jeden argument s výsledkem $36$ (=$((1+2) * 2)^2$).

\begin{figure}[tbh]
	\begin{verbatim*}
	puts naDruhou(1+2)*2
	puts naDruhou (1+2)*2
	\end{verbatim*}
 	\vspace{-0.7cm}
  \caption{Dùle¾itý význam mezer}
  \label{ruby_syntaxe_fig3}
\end{figure}

Ruby neumo¾nuje pojmenovat argumenty metod podobnì jako python, ov¹em díky volné syntaxi pro vytvoøení asociativního pole (hashe) lze toto chování napodobit. Pøíkladem mù¾e být volání fiktivní metody pro hledání \verb|find :name => 'Jarek', :surname => 'Cecho'|, kde opticky pøedávám dva pojmenované parametry - name a surname. Ve skuteènosti je tento zápis reprezentován jako tvorba asociativního pole s klièi name a surname a a¾ naslednì je toto pole pøedáno metodì \verb|find| jako jeden argument. Webový framework Ruby on Rails tento pøístup pou¾ívá velmi èasto.

Poslední poznámka k volné syntaxi, Ruby umo¾nuje stejnì jako Perl otoèení poøadí zápisu neúplné podmínky a jejího tìla (viz. Obrázek \ref{ruby_syntaxe_fig3}).

\begin{figure}[tbh]
	\begin{verbatim}
	if osoba == 'jarcec' then print "Ahoj Jarcec"; end
	print "Ahoj Jarcec" if osoba == 'jarcec'
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøehození poøadí zápisu neúplnì podmínky a jejího tìla}
  \label{ruby_syntaxe_fig4}
\end{figure}

\subsubsection{Dynamiènost a otevøenost}
Dynamièností Ruby rozumím provádìní mnoha èinností, které jsou provádìny v pøípadì C++ èi Javy v dobì kompilace, a¾ za bìhu programu. Vzhledem k plné objektovosti nemá moc smysl mluvit o typovosti jazyka, proto¾e existuje pouze jediný datový typ, kterým je objekt.

Z dynamiènosti vyplývá mnohem zajimavìj¹í a ne a¾ tak bì¾ná vlastnost Ruby, kterou je otevøenost. Ka¾dý objekt mù¾e být za bìhu otevøen a roz¹íøen o nové metody podobnì jako je tomu u JavaScriptu. Velice \u{c}asto se toho vyu¾ívá u tøíd (napøíklad roz¹íøením vìstavìné tøídy o nové metody). Tuto vlastnost by do urèité míry ¹lo nahradit dìdièností (nové metody ulo¾it do potomka), ale jen pokud se roz¹iøují tøídy. V Ruby je v¹e objekt, tak¾e roz¹íøit jdou nejen tøídy, ale dokonce i instance jednotlivých tøíd (viz Obrázek \ref{ruby_dynamicnost_fig1}), co¾ byl pro mì jako¾to programátora v C++ docela ¹ok pøi seznamování se s tímto jazykem. Mo¾nosti roz¹íøení instancí o nové metody pou¾ívám i ve své práci, co¾ popisuji ní¾e v kapitole o zpracování Faktù.

\begin{figure}[tbh]
	\begin{verbatim}
	class A
	def metodaA
			4
		end
	end

	a = A.new
	a.metodaA # => 4

	b = A.new
	def b.metodaB
		5
	end
	b.metodaB # => 5
	a.metodaB # => Exception NoMethodError
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøehození poøadí zápisu neúplnì podmínky a jejího tìla}
  \label{ruby_dynamicnost_fig1}
\end{figure}

Díky dynamiènosti a otevøenosti se v ruby velice pìknì metaprogramuje (co¾ je mnohoznaèný výráz, zde pou¾ívám ve významu psaní k\'{o}du, který generuje dal¹í k\'{o}d). Jedná se o velice èasto vyu¾ívanou schopnost jazyka a velké projekty v Ruby jsou metaprogramováním dosti ovlivnìny. Pøíkladem mù¾e být projekt ActiveRecords\footnote{http://ar.rubyonrails.org/}, který zapouzdøuje èinnost s relaèními databázemi tak, aby se u¾ivatel se SQL vùbec nesetkal. V¹e je pro nìj zapouzdøeno do objektù.

\begin{figure}[tbh]
	\begin{verbatim}
	class Human < ActiveRecords::Base
	end

	jarcec = Human.new
	jarcec.name = "Jarek"
	jarcec.surname = "Cecho"
	jarcec.save
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ukázka pou¾ití knihovny ActiveRecords}
  \label{ruby_dynamicnost_fig2}
\end{figure}

V definici tøídy z Obrázku \ref{ruby_dynamicnost_fig2} chybí deklarace method \verb|name| a \verb|surname| a pøesto daný k\'{o}d bude fungovat. Konstruktor tøídy se toti¾ pøi inicializaci podívá do databáze na strukturu tabulky kterou popisuje, v tomto pøípadì tabulky \verb|humans| a vytvoøí ke v¹em nalezeným sloupcùm pøíslu¹né metody pro ètení i zápis. Tento pøístup velice usnad\u{n}uje údr¾bu k\'{o}du. V definice tøídy není seznam sloupcù jednotlivých tabulek a proto pøi zmìnì databázového schématu není nutné v¹e upravovat a zvedat tak pravdìpodobnost zavleèení chyby díky nekonzistenci seznamu sloupcù v databázi a v definici tøídy.

O metaprogramování v ruby byla napsána velice pìkná kniha - Metaprogramming Ruby\cite{metaprogrammingRuby}. Psána je spí¹e laickým stylem a na praktických pøíkladech popisuje co pøesnì se pod pojmem metapogramovaní skrývá, a jak toho v ruby co nejefektivnìji vyu¾ít.

\subsubsection{Bloky}
Blok je podobnì jako v C++ nebo Javì mno¾ina pøíkazù ohranièená slo¾enymí závorkami. V pøípadì Ruby je je¹tì mo¾né blok ohranièit klíèovými slovy \verb|do| a \verb|end|. Na rozdíl od zmínìných jazykù v Ruby jde s bloky dìlat o dost vìt¹í kouzla a proto je zmi\v{n}uji v samostatné èásti. První dùle¾itý rozdíl je mo¾nost pøedat bloku parametry (a ten se pak vlastnì chová jako bezejmená funkce). Dal¹í rozdíl je schopnost bloky v Ruby pøedávát do method.

\begin{figure}[tbh]
	\begin{verbatim}
	["AHOJ", "NAZDAR", "HI"].map{|prvek| prvek.downcase}
			# => ["ahoj", "nazdar", "hi"]
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ukázka pøedání bloku metodì}
  \label{ruby_bloky_fig1}
\end{figure}

Pøíkladem mù¾e být zámìna velikosti písmen v poli øetezcù na Obrázku \ref{ruby_bloky_fig1}. Metoda \verb|map| tøídy \verb|Array| pøijímá blok akceptující jeden parametr a pro ka¾dý prvek v poli tento blok zavolá. Návratovou hodnotu bloku (v Ruby je v¹e výraz, i bloky tedy vracejí své hodnoty, tato vlastnost je detailnìji popsána ní¾e) ulo¾í do pole na místo volaného prvku. Ukázka tedy zmen¹í velikost písmen pro kazdý prvek v poli.

S bloky se pojí jeden dùle¾íty pojem - uzávìr (anglicky closure). Ka¾dý blok si s sebou nese vazby na lokální promìné známé v dobì jeho vzniku (takzvané bindings). V pøíkladì na Obrázku \ref{ruby_bloky_fig2} si blok ``zapamatuje`` svou lokální promìnou \verb|a| (s hodnotou 30) a nese si ji s sebou i do metody \verb|foo|, odkud je poté zavolán (pomocí klíèového slova \verb|yield|). Ukázka výpí¹e èíslo 30, proto¾e \verb|a| je lokální promìná z kontextu, ve kterém byl pøedaný blok vytvoøen. Pokud by chtìla metoda \verb|foo| vytisknout svou hodnotu promìné \verb|a|, musela by ji pøedat do bloku pøes parametr.

\begin{figure}[tbh]
	\begin{verbatim}
	def foo
		a = 10
		yield # Zavolej predany blok
	end

	a = 30
	foo { puts a } # Vytiskne hodnotu promene a, ale ktere? 10 nebo 30?
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Vazby na lokální promìné v pøípadì pøedaných blokù}
  \label{ruby_bloky_fig2}
\end{figure}


\subsubsection{Drobnosti}
Dále bych se chtìl u¾ jenom krátce zmínit o nìkolika vlastnostech Ruby, které popisem nevydají na samostatnou èást, ale pøesto si myslím, ¾e by zde mìly být uvedeny.

Mimo faktu, ¾e v¹e je objekt, je ka¾dá jazyková konstrukce výraz (má svou návratovou hodnotu). Tedy i øídicí konstrukce (\verb|if|, \verb|while|, ...) nìco vrací - podle funkce pøíslu¹né konstrukce je to tøeba poslední vykonaný pøíkaz nebo \verb|nil| (Obrázek \ref{ruby_drobnosti_fig1}).

\begin{figure}[tbh]
	\begin{verbatim}
	if 1 == 2
	  puts "1 == 2"
	end # => nil
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig1}
\end{figure}

Ruby je plnì objektový a v¹e je objekt popøípadnì jeho metoda. I aritmetické operátory jsou tedy ve skuteènosti metody a jejich zápis bez pøístupové teèky je jen ''syntax sugar`` (jak se doslovnì uvádí v knize  The Ruby Programming Language\cite{rubyProgrammingLanguage}). Jde je tedy podobnì jako v C++ pøetí¾it nebo z daného objektu úplnì odstranit (Obrázek \ref{ruby_drobnosti_fig2}).

\begin{figure}[tbh]
	\begin{verbatim}
	class Fixnum
	  def +(oth)
	    self * oth
	  end
	end #	=> nil
	4 + 2 #	=> 8
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig2}
\end{figure}

Ruby podporuje pouze jednoduchou dìdiènost, co¾ znamená, ¾e tøída mù¾e mít maximálnì jednoho pøedka. Ov¹em absenci implementaènì slo¾ité vícenásobné dìdiènosti vynahrazuje mo¾ností vkládat do sebe moduly (Obrázek \ref{ruby_drobnosti_fig3}).

\begin{figure}[tbh]
	\begin{verbatim}
	module Ahoj
	  def ahoj
	    "Ahoj"
	  end
	end
	class Pozdravy
	  include Ahoj
	end
	p = Pozdravy.new
	p.ahoj # => "Ahoj"
\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig3}
\end{figure}

Na rozdíl od C++ èi Javy jsou v Ruby povoleny na konci metod i jiné znaky ne¾ jen znaky anglické abecedy. Co¾ má veliký dopad na zlep¹enou èitelnost k\'{o}du, jeliko¾ podle konvencí metody vracející booleanovskou hodnotu (true/false) jsou ukonèeny znakem otázníku (napøíklad \verb|Object#nil?|) a metody mìnící stav samotného objektu jsou pro zmìnu ukonèeny vykøièníkem (napøíklad \verb|Array#map!|).

\subsection{Implementace Ruby}
Nejznámìj¹í a asi i souèasnì nejvíce pou¾ívanou implementací Ruby je interpret MRI (Mat'z ruby interpret) od autora jazyka. Ten má ov¹em své velké nedostatky. Pøednì pou¾ívá mark-and-sweep garbage collector. Ten v rámci své ''mark`` fáze zmrazí provádìní programu, co¾  se neblaze odrází na celkové rychlosti interpretace. Dále obsahuje takzvaný ''Global interpreter lock`` (GIL), který znemo¾nuje paralelní zpracování. Programy sice mohou be¾et ve vláknech, ale kvùli jeho pøítomnosti mù¾e v jednu chvíli bì¾et maximálnì jedno vlákno.

Jako podklad pro následný list alternativních implementací jsem pou¾il seznam interpretù a jejich krásné srovnání na webu igvita\footnote{http://www.igvita.com/2009/11/20/state-of-ruby-vms-ruby-renaissance}.

\subsubsection{Ruby Enterprise edition}
Jde o vývojovou vìtvi (fork) MRI implementace verze 1.8.7\footnote{http://www.rubyenterpriseedition.com/index.htm} s vylep¹enou správou pamìti a vymìnìným garbage collectorem. Vznikl jako potøeba optimalizovat ruby pro bìh na serverech pro webové aplikace postavené na Ruby on Rails a je pro nì optimalizován. Je plnì kompatibilní s ruby verze 1.8.7 a podle oficiálních stránek v urèitých pøípadech a¾ o 33\% rychlej¹í. Na portále RubyInside je k dispozici záznám pøedná¹ky\footnote{http://www.rubyinside.com/how-phusion-built-a-more-efficient-ruby-1-8-interpreter-2906.htm} obou autorù  z konference Google Tech Talk (2009, San Francisco), o dùvodech proè se do úprav pustili a také o optimalizacích, které provedli.

\subsubsection{JRuby}
Je implementace ruby v Javì\footnote{http://jruby.org} a vyu¾ívající mo¾ností Java VM - obsahuje plnou paralelizaci (¾ádný GIL). V souèastosti se pracuje na podpoøe ruby verze 1.9. Velmi ¾ivý projekt se 7 aktivními vývojáøi (MRI z nejvìt¹í èásti vyvíjí pouze jeden èlovìk).

\subsubsection{BlueRuby}
Jedná se o implementaci Ruby bì¾ícího uvnitø SAP NetWeaver\footnote{www.SAP.com/cz/ERP} a SAP ERP produktù, tedy dal¹í mo¾nost jak roz¹íøit platformu SAP mimo jazykù ABAP\footnote{http://help.sap.com/saphelp\_nw70/helpdata/en/fc/eb2e97358411d1829f0000e829fbfe/frameset.htm} a Java. Zatím je projekt pouze ve stádiu experimentální implementace\footnote{https://wiki.sdn.sap.com/wiki/display/Research/BlueRuby} a nehodí se pro reálné nasazení.

\subsubsection{Rubinius}
Zajimavý nápad napsat co nejvìt¹í èást ruby v samotném Ruby\footnote{http://rubini.us} - jedná se o pøepsaní nezbytnì nutných èástí interpretu do C++ a zbývajícího k\'{o}du do Ruby (napøíklad standartní tøídy - String, Array, Hash, ...). Intepret obsahuje just in time (JIT) kompilátor - parsovaný skript pøelo¾í prvnì do binárního k\'{o}du spustitelném na dané platformì a a¾ ten následnì spoustí. Tímto dosahuje zrychlení oproti MRI. Díky kompilaci do nativního k\'{o}du není zatí¾en GIL a umo¾nuje tedy plný paralelismus. V souèasné dobì je tento projekt stále ve vývoji - nìkolik aplikací v nìm ji¾ bì¾í, ale pro reálné nasazení není pøíli¹ vhodný.

\subsection{Mo¾nosti binárního roz¹íøení}
Distribuèní tarball MRI verze Ruby obsahuje také soubor README, kde je pìknì popsán rychlý úvod do psaní binárních roz¹íøení.

TODO: Hlubsi uvod

\subsubsection{Pøeklad roz¹íøení}
Binární roz¹íøení se pro MRI pøekládají pomocí pøíkazu \verb|make|, tak jak je tomu u vìt¹iny ostatních projektù v prostøedí Linuxu. Ov¹em na rozdíl od nich není pou¾ita sada programù autotools (skript ./configure pro generaci souboru Makefile). Makefile popisující jak se má roz¹íøení pøelo¾it a nainstalovat toti¾ vygeneruje samo Ruby - existuje modul \verb|mkmf| (MaKe MakeFile), pomocí jeho¾ metod programátor popí¹e na vysoké úrovní abstrakce, jak pøelo¾it jeho roz¹íøení a tento skript potom distribuuje spolu se zdrojovými k\'{o}dy. Celý sled pøíkazù pro pøeklad a instalaci je zobrazen na Obrázku \ref{ruby_rozsireni_fig1}.

\begin{figure}[tbh]
	\begin{verbatim}
	ruby extconf.rb
	make
	make install
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøeklad binárních roz¹íøení}
  \label{ruby_rozsireni_fig1}
\end{figure}

Modul \verb|mkmf| slou¾í hlavnì k nastavení dùle¾itých cest pro pøeklad automaticky a nezávisle na dané verzi èi distribuci operaèního systemu (cesta k hlavièkovým souborùm ruby, jeho knihovnám). Mimo této èinnosti modul nabízí metody, které umo¾nují podobné èinnosti jako skript ./configure\,--\,nalézat cesty k systémovým knihovnám, ovìøováním zda-li obsahují po¾adované symboly (funkce, promìné, ...) a dal¹í podobné funkce. Takto vytvoøený skript je samozøejmì plnìhodnotný program v Ruby. Lze tedy pou¾ít ve¹keré jeho mo¾nosti vèetnì pou¾ití dal¹ích knihoven. Napøíklad jde distribuovat pouze skript bez zdrojových k\'{o}dù, který si prvnì stáhnì nejnovìj¹í verzi projektu a a¾ poté bude pokraèovat ve své obvyklé èinnosti.

\subsubsection{VALUE}
\verb|VALUE| je datový typ, který v C reprezentuje Ruby objekt. V¹e je objekt a proto se tento datový typ pou¾ívá v¹ude\,--\,ka¾dá funkce volatelná z ruby vrací \verb|VALUE| jako svou návratovou hodnotu. Ve skuteènosti se jedná o pøejmenování datového typu \verb|unsigned long| obsahujícího adresu struktury reprezentující daný objekt. Vìt¹inou se tedy jedná o prostý ukazatel. Ov¹em ne ve v¹ech pøípadech. Interpret vyu¾ívá faktu, ¾e ukazatele jsou na platformì x86 v pamìti zarovnány - nejni¾¹í dva bity jsou pro ukazatele v¾dy nulové (platí pro 32 bitovou architekturu, pro 64 bitù se zarovnává na 8 bytù - tedy poslední ètyøi bity ukazatele jsou nulové).

Napøíklad objekty tøídy \verb|Fixnum| (reprezentující celá èísla) nemají svou strukturu jako ostatní objekty, ale jejich hodnota je zak\'{o}dována pøímo do promìné typu \verb|VALUE| tak, ¾e nultý bit (LSB, Least significant bit, nejménì významný bit) je nastaven na jednièku a ostatní bity jsou pou¾ity pro ulo¾ení vlastní hodnoty èísla. Tímto pøístupem se u¹etøí dereferencování ukazatele pøi práci s celými èísly. Samozøejmì zobrazitelný rozsah èísel je tímto pøístupem omezený na 31 bitù (èíslo je ulo¾eno v pamìti jako znaménkové v dopl\v{n}kovém k\'{o}du). Proto Ruby pro pøíli¹ velká celá èísla nabízí je¹tì tøídu \verb|Bignum|, její¾ hodnota není reprezentována pøímo v místì ukazatele a nabízí o dost vìt¹í rozsah.

Tato optimalizace není pou¾ita jen u celých èísel, ale také u singleton promìných významých a èasto pou¾ívaných tøíd. Singleton je oznaèení pro tøídu, která ma maximálnì jednu instanci v celém programu. V Ruby se jedná o instance tøíd \verb|TrueClass| (instance se jmenuje \verb|true|), \verb|FalseClass| (instancí je objekt \verb|false|) nebo \verb|NilClass| (instance je \verb|nil|, obdoba \verb|NULL| v jazyce C, ''prazdný`` nebo také ''¾ádný`` objekt). V¹echny tyto objekty nemají reprezentující strukturu, ale jejich obsah je pøímo zak\'{o}dován do typu \verb|VALUE| pro rychlej¹í interpretaci skriptu. Postup interpretu pøi interpretaci obsahu VALUE je zobrazený na obrázku \ref{fig_ruby_value_diagram}, který jsem pøevzal z èlánku\footnote{http://www.oreillynet.com/ruby/blog/2006/01/the\_ruby\_value\_1.htm} o tomto datovém typu.

\begin{figure}[ht]
  \centering
  \includegraphics[width=13.5cm,keepaspectratio]{./fig/ruby_value_diagram.png}
  \caption{Diagram pro reprezentaci hodnoty v promìné VALUE}
  \label{fig_ruby_value_diagram}
\end{figure}

\subsubsection{Symboly}
\verb|Symbol| je jeden z  datových typù Ruby, jeho¾ popis patøí spí¹e do sekce o vlastnostech, ale kvùli velké návaznosti na jeho vnitøní implementaci jsem se rozhodl zaøadit zmínku o nìm a¾ v této èásti. \verb|Symbol| je textový øetìzec podobný øetìzcùm tøídy \verb|String|, který se pro odli¹ení pí¹e s dvojteèkou pøed vlastním øetezcem. Pokud je symbol navíc slo¾en pouze z písmen, je mo¾né vynechat i jindy povinné uvozovky èi apostrofy (ukázky mo¾ností zápisu symbolu jsou na Obrázku \ref{ruby_symboly_fig1}).

\begin{figure}[tbh]
	\begin{verbatim}
	:ahoj.class # => Symbol
	:'ahoj'.class # => Symbol
	:'ahoj, tady jezisek'.class # => Symbol
	:'4'.class # => Symbol
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Rùzné zpùsoby zadání symbolu}
  \label{ruby_symboly_fig1}
\end{figure}

Symboly v Ruby mají nìkolik odli¹ných vlastností od tøídy \verb|String| - za prvé se jedná o objekty pouze pro ètení (nejde zmìnit hodnota, text symbolu) a druhý a podstatnìj¹í rozdíl je v rovnosti a identitì. V ukázce na Obrázku \ref{ruby_symboly_fig2} se provádí dvì dvojice porovnání na objektech tøíd \verb|String| a \verb|Symbol|. V prvním testu porovnávám objekty zda-li se rovnají (mají-li stejný obsah). Druhý test se ptá na ID (jednoznaèný identifikátor) objektu. Testuje tedy identitu objektu. Testy na rovnost samozøejmì v¾dy uspìjí, proto¾e jak symbol, tak øetìzec obsahují stejné hodnoty. Ov¹em test na identitu v pøípadì øetìzce sel¾e, proto¾e se jedná o dva rùzné objekty (vytvoøené interpretem pøi parsování zdrojového k\'{o}du programu). Symboly jsou si ov¹em identické - jedná se o jednu instanci. Tato dùle¾itá vlastnost symboly pøedurèuje k pou¾ítí na místech konstant nebo klíèù do asociativních polí. Symbol s daným textem existuje v pamìti maximalnì jednou, bez ohledu na poèet výskytù v programu, co¾ vede k ¹etøení pamìtí a zvý¹ení výkonu aplikace.

\begin{figure}[tbh]
	\begin{verbatim}
	'ahoj' == 'ahoj' # => true
	'ahoj'.object_id == 'ahoj'.object_id # => false

	:ahoj == :ahoj # => true
	:ahoj.object_id == :ahoj.object_id # => true
\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Porovnání a test identity symbolu a textového øetìzce}
  \label{ruby_symboly_fig2}
\end{figure}


Na úrovní zdrojových k\'{o}du MRI se jedná o tabulku jednoznaènì pøevádìjící textovou reprezentaci symbolu na datový typ \verb|ID| (co¾ je pøedefinovaný typ \verb|unsigned long|). Ve¹kerá porovnávání na rovnost symbolu jsou ve skuteènosti celoèíselná porovnání, která jsou rychlej¹í ne¾ øetìzcová, èím¾ se dosahuje optimalizace. Symbol je podobnì jako Fixnum pøímo zak\'{o}dován do typu \verb|VALUE|, nedochazí zde tedy k dereferencování ukazatele pro získaní èíselné hodnoty.

Java obsahuje velice obdobný mechanismus pomocí volání \verb|String.intern()|, C++ nic jako symbol bohu¾el nezná.


\subsubsection{API}
Seznam dostupných funkcí, které jsou v binárních roz¹íøení k dispozici zde neopisuji, proto¾e je lze nalézt v pøehledné dokumentaci.

\subsubsection{TODO}
OPTIONAL TODO: Popis toho co to je EigenClass

OPTIONAL TODO: Zapouzrení a moznosti jeho obejiti - private je jen doporuceni na implicitni save, objekt\#instance\_eval

\section{Expertní systémy}
TODO: Popsat co jsou vlastne expertni systemy, jak se s nimi pracuje, cim se lisi od ostatnich, trochu historie.

\subsection{Clips}
TODO: Popsat historii CLIPS, co to je v dnesni dobe. Prakticke ukazky jak se v clips pracuje. Zahrnout kapitolu o rozsiritelnosti.

\subsubsection{Reetùv algoritmus}
Popsat jak funguje.

%=========================================================================
\chapter{Zpùsoby tvorby roz¹íøení}
%=========================================================================

Binární roz¹íøení skriptovacího jazyka je dynamická knihovna napsaná vìt¹inou ve stejném jazyce jako cílový interpret. V pøípadì MRI verze Ruby jsou roz¹íøení psaná v C. Lze je psát i v C++, ale kvùli odli¹ným pøekladovým a linkovacím konvencím se jedná o vyjímeèné pøípady. Tyto knihovny pøi naèítání zpravidla zaregistrují v interpretu nové tøídy a jejich metody namapují na své vlastní funkce. Tímto postupem se roz¹íøí mno¾ina dostupných tøíd a funkcionality pro programy.

Dùvodù proè napsat binární roz¹íøení místo nativního kódu se dá najit nìkolik. Prvním a asi i nejpodstatnìj¹ím je rychlost. Programy napsané v C budou provádìny rychleji ne¾ jejich skriptovací ekvivalenty a proto zapouzdøení nejnároènìj¹ího kódu z Ruby do C pøíná¹í výkonostní vylep¹ení. V rámci standadních Ruby tøíd je k dispozici modul pro práci s XML jménem \verb|REXML| napsaný v èistém Ruby. Existuje k nìmu nìkolik alternativ, z nih¾ napøíklad libxml-ruby\footnote{http://libxml.rubyforge.org/}, co¾ je binární roz¹íøení zapouzdøující práci s XML knihovnou libxml\footnote{http://xmlsoft.org/}, je podle webových stránek projektu a¾ o dva øády rychlej¹í.

Druhým dùvodem mù¾e být nutnost. Standardní knihovny nemùsí zpøístup\v{n}ovat v¹echny po¾adované nízko úrov\v{n}ové mo¾nosti operaèního systému. Programátor je tak nucen napsat si miniroz¹íøení, které právì jím po¾adované vlastnosti zpøístupní.

Poslední dùvod je pohodlnost. Proè pøepisovat celou ji¾ napsanou a navíc i odladìnou knihovnu do jiného jazyka, kdy¾ staèí zpøístupnít pouze její API. Velice dobrým pøíkladem takovýchto knihoven jsou rozhraní pro GUI frameworky GTK\footnote{http://ruby-gnome2.sourceforge.jp/} a QT\footnote{http://www.darshancomputing.com/qt4-qtruby-tutorial/}.

Libovolnou knihovnu napsanou v C jako roz¹íøení pro skriptovací jazyk nelze pou¾ít pøímo, proto¾e by interpret nevìdel, jak s ní má zacházat. Je potøeba napsat rozhraní mezi touto knihovnou a interpretem, které je zodpovìdné za dvì dùle¾ité èinnosti: (1) musí v interpretu registrovat nabízené funkce a tøídy knihovny, (2) musí poskytovat pøekladovou úrovìn pro odli¹né volací konvence knihovny a interpretu. MRI napøíklad vy¾aduje u v¹ech funkcí volatelných z ruby, aby pøijímaly a vracely pouze datový typ \verb|VALUE|. Bì¾ná knihovna nic o specifickém datovém typu interpretu neví a u¾ vùbec netu¹í jak tøídu \verb|String| pøevést na C reprezentaci øetìzce. Za tyto typové pøevody je takté¾ odpovìdná pøekladová úrove\v{n}.

Existují v základì dva odli¹né postupy k tvorbì binarních roz¹íøení skriptovacích jazykù, automatický a manuální. V následujících sekcích se jim budu detailnìji vìnovat.

\section{Automatický postup}
Pomocí speciálních nástrojù lze vrstvu mezi knihovnou a interpretem nechat vygenerovat automaticky. Pøíkladem mù¾e být projekt SWIG\footnote{http://www.swig.org/} (Simplified Wrapper and Interface Generator) slou¾ící pro automatickou tvorbu roz¹íøení pro knihovny napsané v C nebo C++. Seznam podporovaných jazykù je uctyhodný a mimo jiné zahrnuje známé jazyky jako Python, Perl, PHP nebo právì Ruby.

Pou¾ití podobných nástrojù je velice snádné. Vìt¹inou je bez slo¾ité a zdlouhavé konfigurace staèí spustit nad hlavièkovými soubory zpøístup\v{n}ované knihovny. Jako výstup vygenerují rozhraní, zdrojový text v jazyce C nebo C++, který staèí u¾ jen pøelo¾it a poté nahrát v rámci programu vykonávaného v interpretu.

Vygenerovné rozhraní zpravidla obsahuje pro ka¾dou nalezenou funkci knihovny jednu novì vygenerovanou funkci, která slou¾í jako pøekladový obal. Vezme parametry pøedané interpretem a pøelo¾í datové typy do typù knihovny. Pro MRI je tøeba pøevést pøedané objekty do jejich C reprezentací. Tedy pøevést objekt typu \verb|Fixnum| na \verb|integer|, \verb|String| na \verb|char *|, atd.. Poté zavolat obalovanou funkci knihovny a nakonec pøevést její návratovou hodnotu zpìt na Ruby objekt a vrátit ji interpretu. Rozhraní navíc obsahují jednu inicializaèní funkci, která v¹echny vygenerované obalovací funkce zaregistruje aby byly v interpretu k dispozici.

Takto vygenerované rozhraní je velice pøímoèaré a programátor ma minimální kontrolu nad jeho výslednou podobou. Zpøístup\v{n}uje v¹echny funkce knihovny pro jejich volání ze skriptovacího jazyka se zachováním sémantiky jejich argumentù bez jakékoliv vý¹¹í abstrakce. Navíc zde mù¾e být problém se slo¾itými vnitøními datovými typy, které se pou¾ívají i vnì knihovny.

\section{Manuální postup}
Manuálním napsáním spojovací vrstvy získá prográmátor plnou kontrolu nad výsledkem. Jako jednu z hlavních výhod vidím mo¾nost vytvoøit z vnitøních struktur pou¾ivaných i vnì knihovny tøídy a z funkcí nad nimi operujícími metody této tøídy. Výsledkem je krásnì objektové chování, jak jsou programátoøi v Ruby zvyklí na rozdíl od pouhého procedurálního zpøístup\v{n}ení v¹ech funkcí. Navíc není problém zapouzdøovanou knihovnu tøeba roz¹íøit o dal¹í funkcionalitu, která se u¾ ov¹em bude odehrávát pouze na úrovni Ruby.

Na druhou stranu má tento postup oproti automatickému pøístupu jednu obrovskou nevýhodu - èas programátora. Ten mùsí nastudovat rozhraní knihovny, navrhnout jeho vhodné zapouzdøení a nakonec i celé rozhraní napsat. Díky èasové nároènosti se plnì manuální pøístup v praxi pou¾ívá pouze zøídka a pokud je snaha knihovnu je¹tì zapouzdøit na vy¹¹í úrovni, polo¾ením do objektù napøíklad, tak se spí¹e pou¾ívá kombinace obou pøístupù. Automaticky se vytvoøí rozhraní knihovny pøístupné ve skriptovacím jazyce a a¾ toto rozhraní se následnì zapouzdøí do objektù a dal¹ích specifických jazykových konstrukcí, které v C nebo C++ nejsou známy.

%=========================================================================
\chapter{Knihovna rbClips}
%=========================================================================
V této kapitole se budu dùkladnì vìnovat u¾ své vlastní prácí - knihovnì rbClips. Postupnì v následujícíh podkapitolách popí¹i její návrh, nìkteré zajimavé implementaèní detaily a samozøejmì nevynechám shrnutý popis rozhraní. Detaily aplikaèního rozhraní u¾ ov¹em nechám do programové dokumentace. V závìru kapitoly je uvedeno také nìkolik ukázkových pøíkladù, jak se dá rbClips pou¾ít.

\section{Návrh}
Velice jsem rozmý¹lel jak výsledné binární roz¹íøení vytvoøit. Nejjednodu¹¹í pøístup automatického vytvoøení celého rozhraní by zachoval funkce i jejich parametry. U¾ivatel knihovny by ted byl nucel se uèit syntaxi u¾ivatelskéh rozhraní CLIPS, co¾ bylo velice ne¾ádoucí. V úvodních verzích návrh jsem se proto pøiklonil spí¹e ke kombinovanému pøístupu. Nad automaticky vygenerovaným rozhraním napsat vlastní vy¹¹í logiku, která by celé procedurální chování zapouzdøila do objektù. S tímto pøístupem vzniklo nìkolik prototypù knihovny na prezentaci, ¾e je to takto mo¾né vytvoøit (tkz. ''proof of concept``). Prototypy opravdu fungovaly ov¹em trpìly slab¹ím výkonem, kvùli neustálému pøevádìní ve¹kerých datových typù. Napøiklad i jinak velice rychlé ukazatele na úrovni jazyka C byly konvertovaný do objektù a pøedaný do vy¹¹ích vrstev k operacím, aby se následne zpìtnì z objektù pøevedly na ukazatele a vyhledala se podle nich v CLIPS urèitá entita (napøíklad fakt).

Proto jsem se nakonec rozhodl celé rozhraní napsat v jazyce C a dodávat jako plnì binární roz¹íøení. Po dùkladném pøeètìní dokumentace Ruby jsem navíc zjistil, ¾e Ruby umo¾nuje do objektu ulo¾it i ukazatel na libovoulnou strukturu. O tu se stará sám interpret. Garbage collector pøed uvolnìním objektu obsahující ukazatel zavolá registrovanou uvol\v{n}ovací funkci na ulo¾ený ukazatel a a¾ poté objekt odstraní. Nejèastìji je registrováná funkce \verb|free()|, ale v pøípadì potøeby pro slo¾itìj¹í struktury lze zaregistrovat zcela libovolnou funkci (pøijímací právì jeden parametr typu \verb|void *|). Ta mù¾e strukturu postupnì uvolnit tak, aby nedo¹lo k ¾ádným únikùm pamìti.

Do objektù ukládám vlastní struktury, které obsáhují alespo\v{n} jednu promìnou. Tou je ukazatel na danou strukturu v CLIPS. Tedy napøíklad Ruby objekt reprezentující fakt má takto ulo¾en ukazatel na jeho strukturu v CLIPS. Tím padém mám k dispozici rychlé spojení mezi Ruby objektem a jeho CLIPS reprezentací. Nemusím poka¾dé popisovanou entitu vyhledávat a operace v¹echny operace jsou rychlej¹í.

Samotné aplikaèní rozhraní, které je pøístupné u¾ivateli (API), jsem navrhnul po vzoru open source knihovny ActiveRecords (AR). Projekt AR je v Ruby svìtì hlavnì spojován s webovým frameworkem Ruby on Rails a pou¾ívá se k zapouzdøení jazyka SQL do objektù. Stejnì jako AR odsti\v{n}uje programátora od nutnosti znát SQL, tak i rbClips odstin\v{n}uje programátora od nutnosti znát u¾ivatelské rozhraní CLIPS. Ve¹kerou funkcionalita je zapouzdøena do objektù a ovládá se pomocí method tìchto objektù. Hlavní dùvod proè jsem rozhraní navrhl po vzoru AR je jeho velká roz¹íøenost. Jakykoliv programátor, který alespo\v{n} èásteèné zná rozhraní AR se v rbClips velice rychle zorientuje a nebude mít pøíli¹ velké problémy mou knihovnu pou¾ívat.

Inspirace AR se projevila v urèitých vzorech, které jsou shodné napøíè celým API. Mimo vyjímek zmínìných u popisu konkretních tøíd ní¾e v popisu rozhraní obsahují v¹echny tøídy spoleènou podmno¾inu metod zobrazenou na obrázku \ref{common_methods}. Inspirace AR není vidìt jen u spoleèných metod, ale také v chování celé knihovny. Napøíklad vytvoøení instance tøídy Fact, Rule nebo Template automaticky nevytvoøí odpovídající novou entitu i v prostøedí CLIPS. K vytvoøení (ulo¾ení) entity v prostøedí CLIPS dojde a¾ v okam¾iku volání metody \verb|save|. Velice podobnì to funguje i s aktualizací entit, ve¹keré zmìny je potøeba potvrdit opìtovným voláním metody \verb|save|, jinak se zmìny v prostøedí CLIPS nikdy neobjeví.

\begin{figure}[tbh]
\begin{description}
 \item[save] Ulo¾í nebo aktualizuje popisovanou entitu v prostøedí CLIPS.
 \item[saved?] Vrátí boolenovou hodnotu zda-li je daná entita pøítomna v prostøedí CLIPS. 
 \item[destroy!] Vyma¾e danou entitu z CLIPS prostøedí.
 \item[update] Aktualizuje vlastnosti podle aktuální hodnoty v prostøedí CLIPS.
 \end{description}
 	\vspace{-0.7cm}
  \caption{Spoleèná podmno¾ina metod vìt¹iny tøíd knihovny rbClips.}
  \label{common_methods}
\end{figure}

\section{Výhody pou¾ití rbClips}
Výhody, které pou¾ítí rbClips nabízí oproti pøímemù pou¾ití CLIPS, jsou rùznì rozprostøeny v celém tomto textu. Pro pøehlednost jsem se rozhodl je zde dohromady shrnout a zopakovat, aby je ètenáø mìl k dispozici na jednom místì a nemusel slo¾itì prohledávat celý text.

\textbf{Zapouzdøení procedurálního chování.} Manuální pøístup k tvorbì zpøístup\v{n}ovacího binárního roz¹íøení mi umo¾nil zapouzdøit jednotlivé skupiny funkcí do tøíd. Napøíklad v¹echny funkce pracující s fakty jsou a\v{t} u¾ pøímo èi nepøímo volány pomocí method tøídy Fact. Samotná tøída navíc celé rozhraní pøispùsobuje objektovému návrhu a nepsaným konvecím jazyka Ruby. Programátor pou¾ivající rbClips si vùbec nemùsí být vìdom, ¾e na ní¾¹í úrovni se pou¾ívá pouze procedurální knihovna napsaná v jazyce C.

\textbf{Zapouzdøení syntaxe CLIPS.} Zapouzdøení celého rozhraní knihovny rbClips do objektù umo¾nilo schovat u¾ivatelské rozhraní CLIPS. Programátor se tak nemusí uèit dal¹í jazyk, navíc od Ruby velice odli¹ný, kterým by ovládal prostøedí CLIPS. Nìkteré ménì vyu¾ivané konstrukce CLIPS nejsou bohu¾el v rbClips pøímo podporovány, a proto jsem pøidal mo¾nost vkládat a vykonávat validní úryvky CLIPS k\'{o}du pøímo. 

\textbf{Zpìtné volání Ruby method.} Knihovna obsahuje mo¾nost jako akci pro pravidla (konsekvent) nastavit metodu libovolného objektu Ruby. Ta se po aktivaci pravidla zavolá. Do takto volané metody lze pøedat libovolné parametry a to nejen ty známé v dobì tvorby pravidla, ale tøeba i ty které vedly k aktivaci tohoto pravidla.

\textbf{Vyu¾itý v¹ech dostupných Ruby knihoven.} Ve výsledém expertním systému jeho¾ základem bude knihovna rbClips, lze vyu¾ívat naprosto libovolnou Ruby knihovnu. Díky mo¾nosti volání libovolné metody v rámci aktivace pravidel lze napøíklad v dobì vyhodnocení pravidla pou¹tet dotazy v relaèních databázích nebo spou¹tet externí utility.

\section{Pøeklad}
Zdrojové k\'{o}dy knihovny rbClips jsou k dispozici na pøilo¾eném CD. Na tém¾e CD je k dispozici i celý git repozitáø. \u{C}tenáø má tedy pøístup k celé historii projektu, ne jen k jeho odevzdané verzi. Vývoj knihovny dnem odevzdání bakaláøské práce nekonèí a proto lze nejaktuálnìj¹í verzi stáhnout z veøejného git repozitáøe serveru Github (potøebný pøíkaz je na obrázku \ref{github_download}).

Knihovna má dvì hlavní závislosti - CLIPS a Ruby. CLIPS je mo¾nost stáhnout z oficiálních stránek projektu a to zvlá¹\v{t} balíèek se zdrojovými k\'{o}dy a s rùznymi makefile soubory. Makefile soubor pro pøeklad knihovny bohu¾el obsahuje chybu. Chybí v nìm flag -fPIC, bez kterého se nedá dynamická knihovna vytvoøit. Proto jsem se rozhodl umístit zdrojové k\'{o}dy CLIPS, oproti kterým je má bakaláøská práce vytvoøena a otestována, pøímo do svého repositáøe. Odpadá tedy nutnost ruèního stáhnutí a pøelo¾ení CLIPS.

Druhá hlavní závislost\,--\,Ruby\,--\,ji¾ v mém repozitaøi z dùvodu pøítomnosti ve vìt¹inì distribucí a velice aktivnímu vývoji není pøítomna. Pro pøeklad je potøeba mít nainstalován nejen samotný interpret, ale i jeho devel balíèky. Po¾adovaná verze je 1.9.x, dnes ji¾ pouze udr¾ovaná vìtev 1.8 není rbClips podporována a knihovna nepùjde s touto verzí pøelo¾it.

Z obvyklých závislostí je potøeba mít prostøedí pro pøeklad, tedy hlavnì pøekladaè gcc. Z rodiny nástroju autotools je potøeba pouze balíèek s programem make. Ostatní nejsou potøeba, proto¾e Makefile pro pøeklad binárního roz¹íøení vytvoøí Ruby skript, který je pro tyto úèely dodán. V koøenové slo¾ce projektu je ji¾ vytvoøen hlavní soubor Makefile, který obsahuje v¹echny èásti pøekladu pohromadì. Pro samotný pøeklad tedy staèí spustit program make v koøenové slo¾ce knihovny. 

Jako první se pøelo¾í zahrnutá verze CLIPS a následnì se a¾ vlastní knihovna rbClips. V poslední fázi pøekladu se spustí testy, aby u¾ivatel mìl jistotu, ¾e se v¹e pøelo¾ilo správnì.

\begin{figure}[tbh]
	\begin{verbatim}
git clone git://github.com/jarcec/rbclips.git
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Sta¾ení nejnovìj¹í verze knihovny rbClips ze serveru Github.}
  \label{github_download}
\end{figure}

\section{Aplikaèní rozhraní knihovny}
Jak jsem ji¾ zmínil celé aplikaèní rozhraní je navr¾eno podle vzoru ActiveRecords, podle kterého sdílí základní my¹lenky a principy pou¾ívání. Celá knihovna je zapouzdøena v jednom Ruby modulu jménem \verb|Clips|. Ten obsahuje pìt hlavních tøíd - \verb|Fact|, \verb|Template|, \verb|Rule|, \verb|Environment|, \verb|Constraint| - které popisují pøíslu¹né entity v CLIPS a zapouzdøují celou práci s nimi. Dále obsahuje nìkolik pomocných tøíd, které u¾ivatel není oprávnìn vytváøet pøímo. Dostává je jako ji¾ vytvoøené objekty do konfiguraèních blokù hlavních tøíd. Tyto pomocné tøídy budou upøesnìny dále v textu v popisu jednotlivých hlavních tøíd, kde jsou pou¾ívány. Nakonec obsahuje je¹te module \verb|Base| slou¾ící pro volání dùle¾itých funkcí CLIPS, které nejsou souèástí jiných tøíd. 

\subsection{Modul Base}
CLIPS je celé prostøedí pro tvorbu expertních systémù, nikoliv jen knihovna pro tvorbu faktù, pravidel a dal¹ích vìt¹ích entit. Proto obsahuje také velké mno¾ství rùzných dopl\v{n}kových funkcí, které toto prostøedí umo¾nují ovládat. Právì pro tyto funkce existuje modul Base, ve kterém jsou pohromadì metody, které se nedotýkají ¾ádného velkého celku CLIPS, ale nelze si bez nich výsledný expertní systém pøedstavit. Dále uvedu krátky seznam nejdùle¾itìj¹ích metod:

\textbf{run(FixNum = 0)} Metoda run slou¾í k zahájení pou¾ívání pravidel. Bì¾ný postup spu¹tìní programu v CLIPS sestává z vytvoøení mno¾iny pravidel a prvotních faktù a následného spu¹tìní vlastního enginu pro zpracování. Knihovna rbClips na tomto pøístupu nic nezmìnila proto se do zavolání metody run ¾ádná pravidla neaplikují. Pro zamezení pøípadnému nekoneènému cyklu slou¾í jeden argument urèující maximální poèet pravidel, která se smí aplikovat.

\textbf{insert\_command(String)} Knihovna rbClips zapouzdøuje nejpou¾ívanìj¹í èásti CLIPS, bohu¾el ov¹em ne ve¹kerou mo¾nou funkcionalitu. Kvùli absenci 100\% pokrytí jsem vytvoøit metodu \verb|insert\_command|. Na vstupu dostává jako parametr jeden validní pøíkaz CLIPS, který následnì provede. Kvùlí chování funkcí, které jsou v prostøedí CLIPS nakonec zavolány, je pro správnu funkènost nutné, aby pøedaný øetezec obsahoval maximálnì jeden pøíkaz. V pøípadì, ¾e jich bude obsahovat více, tak se provede pouze první z nich. Navíc se do Ruby vrátí informace, ¾e v¹e probìhlo v poøádku, co¾ mù¾e být velice matoucí.

\subsection{Tøída Environment}
CLIPS umo¾nuje soubì¾ný bìh nìkolika prostøedí, které jsou na sobì navzájem nezávislé. Ka¾dé prostøedí má svou vlastní mno¾inu pravidel, faktù a pro spu¹tìní rozhodovacího enginu musí pro ka¾dé prostøedí být spu¹tìna methoda \verb|run|. Souèasná implementace prostøedí v rbClips je napsána mírnì neobjektovì, proto¾e následuje mo¾nosti, které ji CLIPS nabízí. V jeden okam¾ik mù¾e být aktivní pouze jedno prostøedí a to i v pøípadì více vláknové aplikace. Navíc je potøeba pro vícevláknové aplikace dávat pozor na potencionálnì nebezpeèné volání \verb|Environment::new|.  CLIPS novì vytvoøené prostøedí rovnou nastaví jako aktuální, co¾ poru¹uje konvence rbClips. Prostøedí se stává aktivní a¾ po zavolání metody \verb|set\_current| (obdoba metody \verb|save| z ostatních hlavních tøíd). Volání konstruktoru tøídy tedy vytvoøí nové prostøedí a poté pøepne zpìt do starého prostøedí. Toto pøehazování je nebezpeèné právì ve více vláknových aplikacích, kde mohou nastat te¾ko odhalitelné race conditions. Napøíklad se ukládaná pravidla èi fakta mohou ulo¾it do zdánlivì náhodných prostøedí. Proto doporuèuji vytvoøit v¹echna potøebná prostøedí je¹tì pøed samotným vytvoøením vláken.

\subsection{Tøída Constraint}
Na rozdíl od Ruby v CLIPS existuje více datových typù ne¾ pouhý objekt. Existují zde datová primitiva známá z ostatních programovacích jazykù jako napøíklad celá èísla, desetíná èísla èi øetezce. Ve výchozím stavu lze do slotu neseøazených faktù ulo¾it libovolnou hodnotu. Popøípadnì mno¾inu hodnot, jedná-li se o multislot. Z logického hlediska by ov¹em napøíklad do slotu vìk, který jak u¾ z názvu vyplývá ud¾uje vìk osoby, nemìlo pøílis smysl ukládat øetezec. Z toho dùvodu zavádí CLIPS tkz. Constraints. U neseøazených faktù lze v ¹ablonì nastavit u jednotlivých faktù také jejich omezení. Tedy napøíklad ji¾ zmínìné omezení typù, které pro daný slot budou akaceptovány. Mimo toho lze je¹tì omezit pro multisloty napøíklad minimální a maximální poèet prvkù, pro èíselné sloty dolní i horní hranici mo¾né hodnoty nebo pro napodobéní výètového typu lze pøímo vyjmenovat v¹echny hodnoty, které má daný slot akceptovat.

Uvnitø CLIPS bohu¾el neexistuje mo¾nost jak mno¾inu omezení ulo¾it jako samostatnou entitnu. Omezení je v¾dy ulo¾eno a¾ v rámci jednotlivých slotù definovaných ¹ablon. Z toho dùvodu objekty tøídy \verb|Constraint| nemají metodu \verb|save| a nejdou tedy ani ulo¾it. Existují pouze na úrovni interpretu Ruby. Pokud programátor nastaví nìjakému slotu omezení, tak se vezme aktuální stav objektu popisujícího omezení a ten se pou¾ije. Pokud je tento Constraint objekt posléze zmìnìn, tak se zmeny ji¾ zpìtnì nepromítnou do v¹ech míst, kde byly pou¾ity. Z tìchto dùvodù doporuèuji vytvoøit v¹echny objekty popisující omezení na jednou místì a je¹tì pøed tvorbou ¹ablon a dále je ji¾ nemìnit.

\subsection{Tøída Template}


\subsection{Tøída Fact}


\subsection{Tøída Rule}


\section{Pou¾ítí a praktické pøíklady}
První pøíklad (Obrázek \ref{rbclips_complex_example1}) ukazuje vyhledávání savcù na mno¾inì zvíøat a jejich vlastností. Pøíklad by ¹el pøepsat i za zapou¾ítí neseøazeného faktu, ale z ukázkových dùvodu je zde pou¾it seøazený fakt.

\begin{figure}[tbh]
	\begin{verbatim}
	# Fakta se kterými se bude pracovat
	Fact.new('animal', %w(dog)).save
	Fact.new('animal', %w(cat)).save
	Fact.new('animal', %w(duck)).save
	Fact.new('animal', %w(turtle)).save
	Fact.new('warm-blooded', %w(dog)).save
	Fact.new('warm-blooded', %w(cat)).save
	Fact.new('warm-blooded', %w(duck)).save
	Fact.new('lays-eggs', %w(duck)).save
	Fact.new('lays-eggs', %w(turtle)).save
	Fact.new('child-of', %w(dog puppy)).save
	Fact.new('child-of', %w(cat kitten)).save
	Fact.new('child-of', %w(tutrle hatchling)).save

	# Vyhledání savcù podle toho, ¾e se jedná o zvíøata a
	# zároven nekladou vejce
	mammal1 = Rule.new "mammal" do |r|
		r.pattern 'animal', :name
		r.pattern 'warm-blooded', :name
		r.not do |n|
			n.pattern 'lays-eggs', :name
		end
		r.assert 'mammal', :name
	end
	mammal1.save

	# Pravidlo pro nalezení savcùm podle rodièù
	mammal2 = Rule.new "childs" do |r|
		r.pattern 'mammal', :name
		r.pattern 'child-of', :name, :young
		r.assert 'mammal', :young
	end
	mammal2.save

	Base.run
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøíklad pou¾ítí knihovny rbClips}
  \label{rbclips_complex_example1}
\end{figure}

TODO: Dodat alespon jeden dalsi priklad

%=========================================================================
\chapter{Závìr}
%=========================================================================
Knihovnu rbClips jsem úspì¹nì naprogramoval a odzkou¹el na základì testù, které jsem vytvoøil ve fázi navrhu rozhraní knihovny. V souèasné dobì probíha jeji dal¹í testovaní pro odhalení rùzných zavleèených chyb, kterých jsem si pøi vlastním testování nev¹iml. Dal¹ím krokem bude pou¾ít knihovnu k tvorbì expertního systému v Ruby pro automatickou klasifikaci vzorkù, tak jak jsem zmínil v úvodu. 

Výhod pou¾ítí rbClips a Ruby místo pøímého pou¾ítí CLIPS je nìkolik. Za prvé lze vyu¾ít v¹ech ji¾ napsaných knihoven Ruby. V praxi hlavnì vyu¾ijeme mo¾nosti napojení na relaèní databáze, ve kterých jsou ulo¾eny informace o malware (napøíklad kontrolní souèty). Dále nám Ruby umo¾nuje snadné volání externích utilit (napøíklad skenovací engine) a rozhodování na základì jejich výsledkù pøesnì po vzoru lidského pracovníka. Poslední výhoda se ji¾ nevztahuje k rbClips, ale ke CLIPS obecnì. Existuje mo¾nost automaticky vytváøet nová pravidla na základì zji¹tìných zkuteènosti (tedy strojové uèení).

Knihovna rbClips by se mohla vyvíjet i nadále. Souèasný stav pokrýva fakta a pravidla, ale CLIPS nabízí napøíklad i vlastní objektový jazyk COOL. Bylo by velice pìkné v budoucích verzích rbClips pøínest mo¾nost pøímeho vyu¾ítí i tìchto zatím nepokrytých èástí CLIPS.

Navíc by knihovna mohla slou¾it jako základ dopl\v{n}ku ke stávajícímu antivirovému jádru. To klasifikuje viry na základì vyhledávání rùzných vzorù v prohledávaných souborech. K tomu by ¹lo vytvoøit druhé jádro klasifikující malware na základì jeho chování (tedy behaviour detekce), jejím¾ základem by byla právì knihovna rbClips. Operaèní systém by hlásil akce jednotlivých programù. Napøíklad alokace velkého bloku souvislé pamìti, roz¹ifrování dat do této pamìti a její následné spustìní. rbClips knihovna by poté rozhodovala zda-li je chovaní programù správné a pøípustné. Pøípadnì by oznaèila daný program za malware a oznámila v¹e u¾ivateli. Samozdøejmì by výsledné nové jádro antiviru mohlo vyu¾ívat ve¹keré mo¾nosti, které nabízí jak CLIPS, tak i Ruby nabízí. Napøíklad nechat zkontrolovat stávajícím jádrem u¾ roz¹ifrovaný k\'{o}du malwaru, který pøedtím nemusel být detekován.
